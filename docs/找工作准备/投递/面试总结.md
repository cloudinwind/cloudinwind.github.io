
**目标岗位：后端开发，Java**

# 美团

在线笔试

90分钟：10道选择 + 3道编程


## 第一题

### 题目描述
小红（R）、小蓝（B）和小绿（G）正在一个字符串上玩捉迷藏。他们所在的位置用对应字母表示，其他位置为空地（\*）或障碍（#）。 
寻找方可以每秒移动一个位置，躲藏方不能移动。当寻找方移动到躲藏方的位置时，躲藏方被认为被找到。但是在过程中，双方均不可以移动到障碍上。 

当一个人作为寻找方，另外两个人作为躲藏方时，只要寻找方找到一个躲藏方即认为游戏胜利。 

请计算三个人分别作为寻找方时，能够使游戏胜利所需的最少时间。 

输入描述 
```
在一行上输入一个仅由 “ *#RGB ” 组成的字符串 ，保证 “ RGB ” 各只出现一次。 
```

输出描述 
```
在一行上输出三个整数，代表小红、小蓝和小绿作为寻找方时，能够获胜的最少时间；如果无法获胜，则直接输出 -1 。 
```

示例 1： 

输入： 
```
R***B**G 
```

输出： 
```
4 3 3
```


这个问题可以看作是一个最短路径问题，其中障碍物“`#`”不可通过，其他位置可以通过。我们需要计算每个人（R、B、G）作为寻找方时，找到其他两个人中的一个所需的最少时间。

使用广度优先搜索（BFS）是解决这个问题的理想方法，因为 BFS 能够在无权图（每一步移动的代价相同）中找到从起点到终点的最短路径。

### 解决方案：

1. **建模问题**：字符串表示地图，`R`、`B`、`G`分别表示三个人的位置。`*`表示可通过的空地，`#`表示障碍物。
2. **BFS搜索**：我们可以从每个寻找方的位置出发，使用BFS计算从该点到其他两个人位置的最短距离。
3. **最终结果**：对于每个人作为寻找方，取找到两个躲藏方中的最短时间。

### 步骤：

1. 从输入字符串中分别找到 `R`、`B` 和 `G` 的索引位置。
2. 对于每个寻找方（`R`、`B`、`G`），执行一次 BFS，记录从当前寻找方到其他两个人的最短路径。
3. 取最小的非负路径作为答案。如果找不到任何路径，则输出 `-1`。




### 代码
```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class HideAndSeek {

    public static void main(String[] args) {
        // 使用 Scanner 读取输入
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();  // 从标准输入读取一行
        scanner.close();  // 关闭输入流

        // 调用 findMinimumTimes 函数，返回三个整数结果
        int[] result = findMinimumTimes(input);

        // 输出结果
        System.out.println(result[0] + " " + result[1] + " " + result[2]);
    }

    // 计算每个人作为寻找方时的最短时间
    public static int[] findMinimumTimes(String map) {
        // 获取各个角色的索引位置
        int R = map.indexOf('R');
        int B = map.indexOf('B');
        int G = map.indexOf('G');

        // 分别计算 R, B, G 作为寻找方时的最短时间
        int rTime = bfs(map, R, B, G);
        int bTime = bfs(map, B, R, G);
        int gTime = bfs(map, G, R, B);

        return new int[] {rTime, bTime, gTime};
    }

    // BFS 函数，计算从 start 开始到 target1 或 target2 的最短距离
    public static int bfs(String map, int start, int target1, int target2) {
        int n = map.length();
        boolean[] visited = new boolean[n];  // 记录已访问的位置
        Queue<int[]> queue = new LinkedList<>();  // 队列用于 BFS，保存当前索引和步数
        queue.offer(new int[]{start, 0});  // {当前位置，距离}

        visited[start] = true;  // 标记起始位置已访问

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int position = current[0];  // 当前索引位置
            int steps = current[1];     // 当前步数

            // 如果当前位置是目标位置之一，则返回步数
            if (position == target1 || position == target2) {
                return steps;
            }

            // 检查左右两个邻居
            if (position - 1 >= 0 && !visited[position - 1] && map.charAt(position - 1) != '#') {
                queue.offer(new int[]{position - 1, steps + 1});
                visited[position - 1] = true;
            }
            if (position + 1 < n && !visited[position + 1] && map.charAt(position + 1) != '#') {
                queue.offer(new int[]{position + 1, steps + 1});
                visited[position + 1] = true;
            }
        }

        // 如果找不到任何目标，则返回 -1
        return -1;
    }
}
```




## 第二题

### 题目描述
小美有 a 个红砖、b 个蓝砖和 c 个绿砖。每 x 个红砖可以合成 1 个蓝砖，每 y 个蓝砖可以合成 1个绿砖。砖块只能正向合成，不能反向分解。 

一套砖块包含 个红砖、 个蓝砖和 个绿砖。请计算小美最多可以收集多少套砖块。 

输入描述： 每个测试文件均包含多组测试数据。第一行输入一个整数T(1<=T<=100000) 代表数据组数，每组测试数据描述如下： 在一行上输入五个整数 a, b, c, x, y(0<=a, b, c <=1000000000, 1<=x,y<=1000000000)，分别表示红砖、蓝砖、绿砖的数量及合成的比例。 

输出描述： 对于每一组测试数据，在一行上输出一个整数，代表小美最多可以收集到的砖块套数。 

示例： 

输入： 2 1 2 3 4 2 10 2 1 4 2 

输出： 1 2

### 问题分析：

- **初始资源**：有 `a` 个红砖、`b` 个蓝砖、`c` 个绿砖。
- **合成规则**：
    - 每 `x` 个红砖可以合成 1 个蓝砖。
    - 每 `y` 个蓝砖可以合成 1 个绿砖。
- **目标**：最大化套数 `k`，使得在资源限制和合成规则下，可以收集到 `k` 套砖块。

### 解题思路：

我们需要计算在合成规则和初始资源的限制下，最大可能的套数 `k`。由于砖块只能正向合成，不能反向分解，我们需要谨慎地计算每一步的资源消耗。

**使用二分查找**：

- **搜索范围**：`[0, 最大可能的套数]`，其中最大可能的套数可以是 `a + b + c`。
- **判断条件**：对于一个中间值 `k`，判断是否能收集到 `k` 套砖块。

**判断函数 `canMake(k)` 的实现**：

1. **计算需要的额外绿砖数**：
    
    - `needGreen = max(0, k - c)`
2. **计算合成绿砖需要的蓝砖数**：
    
    - `totalBlueNeededForGreen = needGreen * y`
3. **计算需要的总蓝砖数**：
    
    - `totalBlueNeeded = k (用于套装) + totalBlueNeededForGreen`
4. **计算需要的额外蓝砖数**：
    
    - `needBlue = max(0, totalBlueNeeded - b)`
5. **计算合成蓝砖需要的红砖数**：
    
    - `totalRedNeededForBlue = needBlue * x`
6. **计算需要的总红砖数**：
    
    - `totalRedNeeded = k (用于套装) + totalRedNeededForBlue`
7. **判断资源是否足够**：
    
    - `totalRedNeeded <= a`

### 示例计算：

以第一组测试数据 `1 2 3 4 2` 为例：

- 目标套数 `k = 1`：
    
    - `needGreen = max(0, 1 - 3) = 0`
    - `totalBlueNeededForGreen = 0 * 2 = 0`
    - `totalBlueNeeded = 1 + 0 = 1`
    - `needBlue = max(0, 1 - 2) = 0`
    - `totalRedNeededForBlue = 0 * 4 = 0`
    - `totalRedNeeded = 1 + 0 = 1`
    - 判断：`totalRedNeeded (1) <= a (1)`，满足条件，可以收集到 1 套。
- 目标套数 `k = 2`：
    
    - `needGreen = max(0, 2 - 3) = 0`
    - `totalBlueNeededForGreen = 0 * 2 = 0`
    - `totalBlueNeeded = 2 + 0 = 2`
    - `needBlue = max(0, 2 - 2) = 0`
    - `totalRedNeededForBlue = 0 * 4 = 0`
    - `totalRedNeeded = 2 + 0 = 2`
    - 判断：`totalRedNeeded (2) <= a (1)`，不满足条件，不能收集到 2 套。

### 代码
```java
import java.util.Scanner;

public class BrickSets {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();  // 读取测试数据组数
        while (T-- > 0) {
            long a = scanner.nextLong();  // 红砖数量
            long b = scanner.nextLong();  // 蓝砖数量
            long c = scanner.nextLong();  // 绿砖数量
            long x = scanner.nextLong();  // 合成一个蓝砖所需的红砖数量
            long y = scanner.nextLong();  // 合成一个绿砖所需的蓝砖数量

            // 使用二分查找计算最多可以形成多少套砖块
            long left = 0, right = a + b + c;  // 初始范围
            while (left < right) {
                long mid = left + (right - left + 1) / 2;  // 取中间值，避免溢出
                if (canMake(mid, a, b, c, x, y)) {
                    left = mid;  // 如果能收集到 mid 套，则尝试更多套数
                } else {
                    right = mid - 1;  // 如果不能收集到 mid 套，则减少套数
                }
            }

            // 输出结果
            System.out.println(left);
        }
        scanner.close();
    }

    // 判断是否能够收集到 k 套砖块
    public static boolean canMake(long k, long a, long b, long c, long x, long y) {
        // 需要额外的绿砖
        long needGreen = Math.max(0, k - c);  // 需要合成的绿砖数量
        // 合成绿砖所需的蓝砖
        long totalBlueNeededForGreen = needGreen * y;
        // 需要的总蓝砖数
        long totalBlueNeeded = k + totalBlueNeededForGreen;
        // 需要额外的蓝砖
        long needBlue = Math.max(0, totalBlueNeeded - b);
        // 合成蓝砖所需的红砖
        long totalRedNeededForBlue = needBlue * x;
        // 需要的总红砖数
        long totalRedNeeded = k + totalRedNeededForBlue;

        // 判断红砖是否足够
        if (totalRedNeeded > a) {
            return false;
        }
        return true;
    }
}
```





## 第三题

### 题目描述

小美正在一张有向但不一定连通的图上玩游戏。这张图包含  n 个点，第 i  个点的权值为 a_i，当小美从  i 移动到 Nexti 时，游戏规则如下：
- 如果 a_Nexti > a_i，小美的金币将增加 x；
- 如果 a_Nexti <= a_i ，小美的金币将增加 y。
小美会提出 q 次询问，每个询问从某个点  u 出发，移动不超过 k 步，最多能获得多少金币。

输入描述：

第一行输入四个整数  n, q, x, y (1<=n, q <= 2* 100000, -1000000<=x, y<=1000000)代表图上点的数量、询问的次数、规则中金币的增加量。

第二行输入 n 个整数 Next1, Next2, ..., Nextn (1<=Nexti <=n)  表示第  个节点下一步的位置。
第三行输入  n 个整数 a_1, a_2, ... , a_n (1<=a_i<=1000000) ，表示第  i 个节点的权值。
此后 q  行，每行输入两个整数  u, k (1<=u<=n,1<=k<=1000000000)代表一次询问的起始点和步数限制。


输出描述：
对于每一次询问，在一行上输出一个整数，代表最多能获得的金币数量。


示例：
输入：
```
4 5 -2 3
2 3 4 1
5 10 3 2
1 1
1 2
1 4
2 4
2 7
```
输出：
```
0
1
4
6
8
```

说明：
对于示例：
对于第一次询问，走一步会扣除  2金币，但是可以选择站在原地不走；
对于第二次询问，走一步时金币数量减至  -2，走两步金币数量变更为  -2+3=1。


### 问题分析

- **关键问题**：当步数 kkk 较小时，我们需要精确地计算在有限步数内能够获得的最大金币数。之前的代码在处理环时，直接使用了环的总金币数和最大子段和，没有考虑剩余步数的限制，导致结果不准确。
    
- **解决方案**：为了准确计算在剩余步数内能够获得的最大金币数，我们需要在进入环后，模拟最多  $\min(k, 2 \times \text{环的长度})$ 步的移动。这是因为在环内，最坏情况下，我们需要遍历两次环才能找到最大的子段和。

### 代码

```java
import java.util.*;

public class XiaoMeiGame {
    static int n, q;
    static long x, y;
    static int[] Next;
    static int[] a;
    static int[] status;  // 0: 未访问, 1: 访问中, 2: 已访问
    static int[] step;    // step[node]: 到达节点的步数
    static long[] coins;  // coins[node]: 到达节点的累计金币数
    static int[] cycleId; // cycleId[node]: 节点所属的环的编号
    static int[] cyclePos;// cyclePos[node]: 节点在环中的位置
    static List<List<Integer>> cycles = new ArrayList<>();
    static List<Long> cycleTotalCoins = new ArrayList<>();
    static List<Integer> cycleLength = new ArrayList<>();
    static List<long[]> cycleGains = new ArrayList<>();

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        q = sc.nextInt();
        x = sc.nextLong();
        y = sc.nextLong();
        Next = new int[n];
        a = new int[n];
        for (int i = 0; i < n; i++) {
            Next[i] = sc.nextInt() - 1;  // 调整为从0开始的索引
        }
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        status = new int[n];
        step = new int[n];
        coins = new long[n];
        cycleId = new int[n];
        cyclePos = new int[n];
        Arrays.fill(cycleId, -1);

        // 预处理
        for (int i = 0; i < n; i++) {
            if (status[i] == 0) {
                dfs(i, 0, 0, new HashMap<>());
            }
        }

        // 读取查询并输出结果
        for (int i = 0; i < q; i++) {
            int u = sc.nextInt() - 1;  // 调整为从0开始的索引
            long k = sc.nextLong();
            long ans = getMaxCoins(u, k);
            System.out.println(ans);
        }
    }

    // 深度优先搜索，寻找环并预处理
    static void dfs(int u, int currStep, long currCoins, Map<Integer, Integer> map) {
        status[u] = 1;
        step[u] = currStep;
        coins[u] = currCoins;
        map.put(u, currStep);

        int v = Next[u];
        long gain = (a[v] > a[u]) ? x : y;
        if (status[v] == 0) {
            dfs(v, currStep + 1, currCoins + gain, map);
        } else if (status[v] == 1) {
            // 找到一个环
            List<Integer> cycle = new ArrayList<>();
            List<Long> gains = new ArrayList<>();
            long totalCoins = 0;

            int node = v;
            do {
                int nextNode = Next[node];
                long edgeGain = (a[nextNode] > a[node]) ? x : y;
                totalCoins += edgeGain;
                gains.add(edgeGain);
                cycle.add(node);
                cycleId[node] = cycles.size();
                node = nextNode;
            } while (node != v);

            cycles.add(cycle);
            cycleTotalCoins.add(totalCoins);
            cycleLength.add(cycle.size());
            cycleGains.add(gains.stream().mapToLong(Long::longValue).toArray());
        }
        // 已访问完节点u
        status[u] = 2;
    }

    // 计算查询的最大金币数
    static long getMaxCoins(int u, long k) {
        long maxCoins = 0;
        int currNode = u;
        long currCoins = 0;
        long steps = 0;
        Map<Integer, Long> visited = new HashMap<>();
        while (steps < k && !visited.containsKey(currNode)) {
            visited.put(currNode, steps);
            int nextNode = Next[currNode];
            long gain = (a[nextNode] > a[currNode]) ? x : y;
            currCoins += gain;
            steps++;
            currNode = nextNode;
            maxCoins = Math.max(maxCoins, currCoins);
            if (cycleId[currNode] != -1) {
                break;
            }
        }
        if (steps == k || cycleId[currNode] == -1) {
            return maxCoins;
        }
        // 处理环
        int cid = cycleId[currNode];
        int len = cycleLength.get(cid);
        long[] gains = cycleGains.get(cid);
        long totalCycleGain = cycleTotalCoins.get(cid);
        long remainingSteps = k - steps;

        // 模拟环内移动，最多遍历2次环，避免时间过长
        int maxSimulateSteps = (int) Math.min(remainingSteps, 2 * len);
        long tempCoins = currCoins;
        int tempNodeIndex = -1;
        for (int i = 0; i < cycles.get(cid).size(); i++) {
            if (cycles.get(cid).get(i) == currNode) {
                tempNodeIndex = i;
                break;
            }
        }
        for (int i = 0; i < maxSimulateSteps; i++) {
            int idx = (tempNodeIndex + i) % len;
            tempCoins += gains[idx];
            maxCoins = Math.max(maxCoins, tempCoins);
        }
        // 如果剩余步数大于模拟的步数且环的总增益为正，可以通过完整循环获得更多金币
        if (remainingSteps > maxSimulateSteps && totalCycleGain > 0) {
            long cyclesCount = (remainingSteps - maxSimulateSteps) / len;
            tempCoins += cyclesCount * totalCycleGain;
            maxCoins = Math.max(maxCoins, tempCoins);
        }
        return maxCoins;
    }
}
```

### 代码说明

1. **在 `dfs` 函数中**：
    
    - 记录了每个环的增益数组 `gains`，用于后续计算最大金币数。
2. **在 `getMaxCoins` 函数中**：
    
    - **步骤 1**：在进入环之前，逐步移动，并记录累计金币数 `currCoins` 和已访问节点，直到步数用完或进入环。
    - **步骤 2**：如果在步数用完之前进入了环，模拟在环内的移动。
        - **模拟步数**：为了保证效率，最多模拟 min⁡(剩余步数,2×环的长度)\min(\text{剩余步数}, 2 \times \text{环的长度})min(剩余步数,2×环的长度) 步。
        - **模拟过程**：从当前节点开始，按照环的顺序累加金币数，并更新 `maxCoins`。
    - **步骤 3**：如果剩余步数超过了模拟的步数，并且环的总增益为正，那么可以通过完整循环环来获得更多金币。
        - 计算可以完整循环的次数，并累加相应的金币数。


过了30%


# Vivo
先做了人才测评, 9.12日晚发了笔试邮件，9.13下午3点笔试
题目类型：6道单选，4道多选，3道编程题

## 第一道编程题：签到题
### 题目描述
Vivo项目组新老员工分组完成任务，员工数组staff，其中0表示新员工，1表示老员工
分组规则如下：
1、一个小组至多3个员工
2、一个小组中最多有1个老员工
3、如果一个小组中有1个老员工，那么这组最多有2个员工

求最小的分组数。


输入描述：
输入员工数组 staff，元素只包含0,1
输出描述：
输出一个整数，表示最小分组数



## 第二道编程题：滑动窗口
### 题目描述
你是一名手机应用开发工程师，需要分析应用在手机上的内存使用情况。你有一个数组 memoryUsage，其中 memoryUsage[i] 表示应用在第 i 秒的内存使用量（以MB为单位）。为了评估应用的稳定性，你需要找出每个连续 k 秒内的内存使用量的波动范围（即最大值与最小值的差值），并返回这些波动范围。

输入
```
[80, 100, 70, 90, 60, 85, 75, 95, 110],4
```

输出 
```
[30,40,30,30,35,35]
```

### 答案

使用滑动窗口技术来高效地计算每个连续 k 秒内的内存使用量的波动范围。
使用双端队列（Deque）来维护当前窗口中的最大值和最小值。这样可以在 O(n) 时间复杂度内完成计算，其中 n 是数组的长度。

```java
import java.util.Deque;
import java.util.LinkedList;

public class MemoryUsageAnalysis {
    public static void main(String[] args) {
        int[] memoryUsage = {80, 100, 70, 90, 60, 85, 75, 95, 110};
        int k = 4;
        int[] result = calculateFluctuationRange(memoryUsage, k);
        for (int r : result) {
            System.out.print(r + " ");
        }
    }

    public static int[] calculateFluctuationRange(int[] memoryUsage, int k) {
        int n = memoryUsage.length;
        if (n == 0 || k > n) return new int[0];

        int[] result = new int[n - k + 1];
        Deque<Integer> maxDeque = new LinkedList<>();
        Deque<Integer> minDeque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            // Remove indices that are out of the current window
            while (!maxDeque.isEmpty() && maxDeque.peekFirst() <= i - k) {
                maxDeque.pollFirst();
            }
            while (!minDeque.isEmpty() && minDeque.peekFirst() <= i - k) {
                minDeque.pollFirst();
            }

            // Maintain the decreasing order for maxDeque
            while (!maxDeque.isEmpty() && memoryUsage[maxDeque.peekLast()] <= memoryUsage[i]) {
                maxDeque.pollLast();
            }
            // Maintain the increasing order for minDeque
            while (!minDeque.isEmpty() && memoryUsage[minDeque.peekLast()] >= memoryUsage[i]) {
                minDeque.pollLast();
            }

            maxDeque.offerLast(i);
            minDeque.offerLast(i);

            // Calculate the result for the current window
            if (i >= k - 1) {
                int max = memoryUsage[maxDeque.peekFirst()];
                int min = memoryUsage[minDeque.peekFirst()];
                result[i - k + 1] = max - min;
            }
        }
        return result;
    }
}
```

初始化：
- maxDeque 用于维护当前窗口的最大值的索引。
- minDeque 用于维护当前窗口的最小值的索引。

遍历数组：
- 对于每个元素，首先移除已经超出当前窗口范围的索引。
- 维护 maxDeque 使其保持递减顺序，维护 minDeque 使其保持递增顺序。
- 将当前索引添加到 maxDeque 和 minDeque 中。
- 当 当前索引已经达到至少 k 的窗口大小时，计算当前窗口的最大值和最小值的差值，并将结果存入 result 数组。

输出结果：
- 遍历完成后，result 数组中保存了每个连续 k 秒内的内存使用量的波动范围。


## 第三道编程题：回溯
### 题目描述
Vivo为回馈粉丝，进行礼品派发活动，不同礼品价格不同，为公平起见，需要将全部的礼品公平的分配到粉丝手中，且每位粉丝拿到的礼品总价格相同。请帮忙确认以下的礼品数量和价格是否可以满足公平的分配原则，可以则返回true，否则返回false。

例如：

价格分别为 5, 4, 1, 3, 2, 3, 2 的礼物是否可以公平分配到4名粉丝手？答案是可以的，按(5)、(2,3)、(2,3)、(1,4)组合，第一位粉丝分配到价格为5的礼物，第二位分配到价格为2和3的礼物，第三位分配到价格为2和3的礼物，第四位分配到价格为1和4的礼物，全部礼物分配完，最后返回true，代表可以公平分配。

程序需要输入的参数是价格数组和粉丝人数（数组元素和粉丝人数均小于1000）


示例：
输入：
```
[5,4,1,3,2,3,2],4
```

输出：
```
true
```

### 思路

1. 检查是否能分配：
	- 计算所有礼品价格的总和 S。
	- 如果总和 S 不能被粉丝人数 k 整除，则不能公平分配，返回 false。
	- 计算每个粉丝应该得到的礼品总价格，即 targetSum = S / k。
2. 使用回溯算法：
	- 尝试将礼品分配到不同的粉丝，确保每个粉丝的礼品总价格都等于 targetSum。
	- 使用回溯法遍历所有可能的分配方式，确保每个粉丝都能够获得符合条件的礼品组合。
3. 优化：
	- 对礼品价格进行排序，以提高效率，先处理大价格的礼品可以减少回溯的深度。

### 答案
```java
import java.util.Arrays;

public class FairDistribution {
    public static void main(String[] args) {
        int[] prices = {5, 4, 1, 3, 2, 3, 2};
        int k = 4;
        System.out.println(canDistribute(prices, k));  // 输出: true
    }

    public static boolean canDistribute(int[] prices, int k) {
        int total = Arrays.stream(prices).sum();
        if (total % k != 0) {
            return false;
        }
        int targetSum = total / k;
        int n = prices.length;
        
        // 先排序以优化回溯性能
        Arrays.sort(prices);
        // 如果最大值大于目标总和，不能分配
        if (prices[n - 1] > targetSum) {
            return false;
        }
        
        boolean[] used = new boolean[n];
        return canDistributeHelper(prices, used, 0, k, 0, targetSum);
    }

    private static boolean canDistributeHelper(int[] prices, boolean[] used, int start, int k, int currentSum, int targetSum) {
        if (k == 0) {
            return true;
        }
        if (currentSum == targetSum) {
            // 当前组分配完，开始下一个组
            return canDistributeHelper(prices, used, 0, k - 1, 0, targetSum);
        }

        for (int i = start; i < prices.length; i++) {
            if (!used[i] && currentSum + prices[i] <= targetSum) {
                used[i] = true;
                if (canDistributeHelper(prices, used, i + 1, k, currentSum + prices[i], targetSum)) {
                    return true;
                }
                used[i] = false;
            }
        }
        return false;
    }
}
```


# OPPO 
直接笔试，2个小时 20道单选+3道编程题

## 第一题：贪心

### 题目描述

小红有一个长度为 n 的数组{a_1, a_2, ......, a_n} ，小红需要执行 k 次操作，操作内容如下：
- 选择一个数组元素 a_i，令 a_i = a_i 按位异或 1
小红想让数组元素之和最大，请你输出这个值。

输入描述:
第一行输入两个整数 n, k 代表数组中的元素数量、操作数量。
第二行输入 n 个整数 代表数组元素。
其中 1<=n<=100000, 1<=k<=1000000000
数组中的每个元素 a_i 满足1<= a_i<=1000000000

输出描述:
在一行上输出一个整数，代表最大的数组元素之和。

示例：
输入：
5 3
1 2 3 4 5

输出
16

### 思路

这个问题的目标是通过执行最多 kkk 次按位异或操作，让数组的元素之和尽可能大。

按位异或操作 `a_i = a_i 异或 1` 的作用是：如果 `a_i` 是偶数，则将其变为奇数；如果 `a_i` 是奇数，则将其变为偶数。因此：

- 对偶数执行异或操作可以让它增加 1（变成更大的奇数）。
- 对奇数执行异或操作会让它减少 1（变成更小的偶数）。

优化思路：

1. **贪心策略**：
    
    - 如果 a_i​ 是偶数，我们希望对其执行异或操作，这样可以让它增加 1。
    - 如果 a_i​ 是奇数，我们尽量不对其执行异或操作，因为这样会减少它的值。
2. **优先处理偶数**：
    
    - 将数组中的偶数尽可能变为奇数，因为这样可以增加总和。
    - 如果操作次数 k 用完后还有剩余，剩下的操作需要交替对奇数和偶数进行反转。
3. **处理剩余操作**：
    
    - 如果 k 次操作后还有剩余，且剩下的次数是偶数次，那么不需要再改变数组，因为两次操作对同一个数会恢复原值。
    - 如果剩余次数是奇数次，则可以对任意一个元素进行一次异或操作，影响最小的选择是对某个奇数执行一次异或。

算法步骤：

1. 遍历数组，将偶数按位异或，使其变成奇数。
2. 计算剩余的操作次数。
3. 如果剩余操作是奇数次，则对影响最小的元素（奇数）执行一次异或。


### 答案
```java
import java.util.Scanner;

public class MaximizeArraySum {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 输入 n 和 k
        int n = scanner.nextInt();
        long k = scanner.nextLong();
        
        // 输入数组
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
        // 统计初始的数组总和
        long sum = 0;
        for (int num : arr) {
            sum += num;
        }

        // 遍历数组，处理偶数元素
        for (int i = 0; i < n && k > 0; i++) {
            if (arr[i] % 2 == 0) { // 如果是偶数，执行异或操作
                arr[i] = arr[i] ^ 1; // 使偶数变为奇数
                sum += 1; // 偶数异或后加1，所以总和增加1
                k--; // 执行了一次操作
            }
        }
        
        // 如果剩下的 k 还不为0且是奇数，需要再处理一次异或
        if (k > 0 && k % 2 == 1) {
            // 对最小的元素再执行一次异或操作，选择改变后最小影响的元素
            int minElement = Integer.MAX_VALUE;
            for (int num : arr) {
                minElement = Math.min(minElement, num);
            }
            // 异或操作会让这个最小的元素增减 1
            sum -= minElement; // 先减去当前的最小值
            sum += minElement ^ 1; // 再加上异或 1 后的值
        }
        
        // 输出最大的总和
        System.out.println(sum);
        
        scanner.close();
    }
}

```


### 代码解析：

1. **输入处理**：我们读取数组的长度 n 和操作次数 k，并初始化数组。
2. **初始总和计算**：在不进行操作的情况下，先计算出数组的总和。
3. **处理偶数**：我们遍历数组，将偶数通过异或 1 变成奇数，并增加总和。
4. **处理剩余操作**：如果剩余的操作次数 kkk 是奇数，那么就选择数组中最小的元素执行一次异或操作，确保对总和的影响最小。
5. **输出结果**：最后输出最大化的数组总和。

复杂度分析：

- **时间复杂度**：O(n)，我们只需遍历数组一遍，来处理所有偶数并计算总和。
- **空间复杂度**：O(1)，只需常数空间来存储几个变量。


## 第二题
### 题目描述
小红有一个长度为  n 的数组  {a_1, a_2, ..., a_n}。小红可以进行若干次操作，每次操作可以选择一个数p (1<=p<=n-1) ，将数组分成 [1, p] 和 [p+1,n] 两部分，然后分别对这两部分进行反转。
例如，对于数组 [1, 2, 3, 4, 5]，如果 p=2，则操作后的数组为 [2, 1, 5, 4, 3]。
小红想对数组进行若干次操作，然后截取一个非空子数组，使得截取的子数组元素和最大，问最大的元素和是多少。


输入描述
第一行输入一个整数  n (1<=n<=100000)代表数组中的元素数量。
第二行输入 n 个整数 a_1, a_2, ..., a_n (1<=a_i<=1000000000)表示数组元素。

输出描述：
在一行上输出一个整数，代表最大的元素和

示例：
输入：
5
3 4 -5 -1 2
输出：
9


### 思路

为了充分利用反转操作的潜力，我们需要考虑以下两点：

1. **不进行任何反转的最大子数组和**：即直接使用 Kadane's Algorithm 得到当前数组的最大子数组和。
2. **一次反转后的最大子数组和**：通过反转操作，我们可以优化子数组的和。特别是考虑“前缀”和“后缀”的组合，反转会将前缀和后缀互换，因此我们需要计算可能通过反转获得的更优子数组和。

解决方案：

1. **正向 Kadane's Algorithm**：计算数组的最大子数组和，代表不做任何反转的情况。
2. **反向 Kadane's Algorithm**：计算数组从后往前的最大子数组和，代表进行一次反转后，可以将一些负数移动到后面或前面以优化结果。

我们需要计算出以下几个部分：

- 原始数组中正向的最大子数组和。
- 反向时的前缀和后缀的组合，找出反转后可以获得的最大子数组和。

### 答案
```java
import java.util.Scanner;

public class MaxSubarraySumWithReverse {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 读取输入的 n
        int n = scanner.nextInt();
        
        // 读取数组
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
        // 计算最大子数组和（不做反转）
        long maxNormal = kadaneMaxSubarraySum(arr);
        
        // 计算可能通过反转获得的最大子数组和
        long maxWithReverse = maxSubarraySumWithReverse(arr);
        
        // 输出最大值
        System.out.println(Math.max(maxNormal, maxWithReverse));
        
        scanner.close();
    }
    
    // Kadane's Algorithm 实现，计算最大子数组和
    public static long kadaneMaxSubarraySum(int[] arr) {
        long currentMax = arr[0];
        long globalMax = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            currentMax = Math.max(arr[i], currentMax + arr[i]);
            globalMax = Math.max(globalMax, currentMax);
        }
        
        return globalMax;
    }
    
    // 计算通过一次反转获得的最大子数组和
    public static long maxSubarraySumWithReverse(int[] arr) {
        int n = arr.length;
        
        // 前缀最大和
        long[] prefixMax = new long[n];
        long currentPrefixSum = 0;
        long maxPrefix = Long.MIN_VALUE;
        
        for (int i = 0; i < n; i++) {
            currentPrefixSum += arr[i];
            maxPrefix = Math.max(maxPrefix, currentPrefixSum);
            prefixMax[i] = maxPrefix;
        }
        
        // 后缀最大和
        long[] suffixMax = new long[n];
        long currentSuffixSum = 0;
        long maxSuffix = Long.MIN_VALUE;
        
        for (int i = n - 1; i >= 0; i--) {
            currentSuffixSum += arr[i];
            maxSuffix = Math.max(maxSuffix, currentSuffixSum);
            suffixMax[i] = maxSuffix;
        }
        
        // 寻找通过一次反转可以得到的最大子数组和
        long maxSumWithReverse = Long.MIN_VALUE;
        
        for (int p = 0; p < n - 1; p++) {
            maxSumWithReverse = Math.max(maxSumWithReverse, prefixMax[p] + suffixMax[p + 1]);
        }
        
        return maxSumWithReverse;
    }
}
```

### 代码解释：

1. **Kadane's Algorithm**：用于计算数组的最大子数组和，这部分不考虑反转，直接应用 Kadane 算法。
    
2. **maxSubarraySumWithReverse 函数**：
    
    - 计算数组的前缀和后缀最大值。
    - `prefixMax[i]` 表示从数组的开头到第 `i` 个元素的最大子数组和。
    - `suffixMax[i]` 表示从数组的第 `i` 个元素到数组末尾的最大子数组和。
    - 在反转时，我们选择一个位置 `p`，将数组分成前缀 `[1, p]` 和后缀 `[p+1, n]`，分别反转这两部分。为了获得最优解，我们找出某个位置 `p` 使得 `prefixMax[p] + suffixMax[p + 1]` 最大。
3. **比较最大值**：我们取不反转时的最大子数组和 `maxNormal` 和反转后可能获得的最大子数组和 `maxWithReverse` 中的较大值，作为最终的结果。


## 第三题：
### 题目描述
小红有两个长度为 n 的数组 {a_1, a_2, ..., a_n} 和 {b_1, b_2, ..., b_n} ，定义数组  a和数组 b 的距离为 (a_1-b_1)^2 + (a_2 - b_2)^2 + ... + (a_i - b_i)^2 + ... + (a_n - b_n)^2。
小红最多可以进行 k 次操作，每次操作可以选择数组 a 或数组 b 中的一个元素，将其加一或减一。请问小红最多可以将两个数组的距离缩小到多少。

输入描述：
第一行输入两个整数 n,k (1<=n<=100000, 0<=k<=1000000000) 分别代表数组中的元素数量、最多可以进行的操作次数。
第二行输入  n 个整数a_1, a_2, ..., a_n(1<=a_i<=1000000000)  表示数组 a。
第三行输入  n 个整数b_1, b_2, ..., b_n(1<=b_i<=1000000000)  表示数组 b。

输出描述：
输出一个整数，表示最多可以将两个数组的距离缩小到多少。由于答案可能很大，输出答案对 1000000000+7 取模的结果。

示例：
输入：
5 3
1 2 3 4 5
5 4 3 2 1
输出：
21

### 思路

1. **初始距离计算**：首先计算初始的距离，即对每一对元素 (ai,bi)(a_i, b_i)(ai​,bi​) 计算 (ai−bi)2(a_i - b_i)^2(ai​−bi​)2 的和。
    
2. **优先减少差距大的项**：我们希望尽量减小那些差值绝对值最大的项的平方值，因此每次操作我们需要选择绝对差值最大的元素进行调整。
    
3. **调整后的差值**：每次对差值最大的项进行调整，将其减少（加1或减1），然后重新计算这个位置的平方差。
    
4. **贪心策略**：每次找到当前最大差值的项，进行一次操作，使得距离尽可能减少。可以使用最大堆（优先队列）来追踪当前最大差值的位置和值。
    
5. **取模计算**：最后结果对 10^9 + 7 取模。
    

具体步骤：

1. 初始化计算每一对元素 a_i​ 和 b_i​ 的差值平方，并计算出总距离。
2. 将每一对元素的差值按绝对值大小放入优先队列。
3. 每次从队列中取出当前绝对差值最大的项，执行一次操作（将其增大或减小1，取决于差值的符号），并更新优先队列中的该项。
4. 重复该操作最多执行 `k` 次。
5. 最后计算出更新后的距离，并对 10^9 + 7 取模。

### 代码
```java
import java.util.PriorityQueue;
import java.util.Scanner;

public class MinimizeArrayDistance {
    // 模数
    static final long MOD = 1000000000 + 7;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 输入 n 和 k
        int n = scanner.nextInt();
        long k = scanner.nextLong();
        
        // 输入数组 a 和 b
        int[] a = new int[n];
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        for (int i = 0; i < n; i++) {
            b[i] = scanner.nextInt();
        }
        
        // 优先队列，存储绝对差值，最大堆
        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> Integer.compare(Math.abs(y), Math.abs(x)));
        
        // 初始计算距离并将差值放入优先队列
        long initialDistance = 0;
        for (int i = 0; i < n; i++) {
            int diff = a[i] - b[i];
            pq.offer(diff);
            initialDistance += (long) diff * diff;
        }
        
        // 贪心减少距离
        while (k > 0 && !pq.isEmpty()) {
            int diff = pq.poll();
            int newDiff;
            
            if (diff > 0) {
                newDiff = diff - 1;
            } else if (diff < 0) {
                newDiff = diff + 1;
            } else {
                newDiff = 0; // 如果差值为 0，不能再减少了
            }
            
            // 更新总距离
            initialDistance -= (long) diff * diff;
            initialDistance += (long) newDiff * newDiff;
            pq.offer(newDiff);
            
            k--;
        }
        
        // 输出结果，对 MOD 取模
        System.out.println(initialDistance % MOD);
        
        scanner.close();
    }
}
```

并没有完全A


# 小红书

2个小时：20道选择 + 3道编程



## 第一题

### 题目描述


小红书的第 i 篇文章有一个点赞数 ai 。小红认为，如果两篇不同的文章满足：点赞数通过位异或运算恰好得到 k ，那么这两篇文章是相似文章，即ai xor aj=k 。

现在小红收集到了 n 篇文章的点赞数，请帮助她计算出有多少对 (i,j) 是相似文章。


输入描述
第一行输入两个整数 $n，k(1≤n≤2*105,0≤k≤109)$ 代表文章总数与相似文章判断值。

第二行输入 n 个整数 a1,a2,...,an(0≤ai≤109) 代表每篇文章的点赞数。

输出描述
在一行上输出一个整数，代表相似文章的对数。


样例输入
4 5
1 1 3 4

样例输出
2

提示
可以发现，1 xor 4 = 5 ，那么文章一和四、文章二和四为两对相似文章。


## 第二题：

### 题目描述： 
小红书总部有一间神秘的魔法阅读室，它四四方方的，三边长为 x,y 和 z ：在三维空间内，我们可以假定它占据了 (0,0,0) 到 (x,y,z) 的空间。有魔法的地方在于，这里面是不存在重力的！这样一来，阅读桌就可以漂浮在任何位置。 

小红书的大家都非常的热爱阅读，特别是在魔法阅读室里！所以，为了搭配魔法阅读室，大家购买了一张魔法阅读桌：这个桌子的体积为 k ，边长可以为任何的正整数。你需要将魔法阅读桌放入魔法阅读室，使得阅读桌的各边平行于对应轴，并且每个角都位于整数坐标上。 在所有可能的边长选取情况下，旋转桌子被视为一种方向，找到全部三种方向里摆放方式数量最多的那种情况的数量之和。例如下图中，在 3*1*2 的空间里有一张边长为 (2,1,1) 的阅读桌，左右方向有 4 种摆放方式，而竖直方向只有 3 种摆放方式，故我们选取左右方向计入答案。 

输入描述 
每个测试文件均包含多个测试点。第一行输入一个整数 T(1≤T≤1000) 代表测试数据组数，每组测试数据描述如下： 第一行输入四个整数 x,y,z 和 k(1≤x,y,z≤1000,1≤k≤109) ，分别代表魔法阅读室的三边长和魔法阅读桌的体积。 除此之外，保证所有的 x 之和，y 之和以及所有的 z 之和均不超过 1000 。 

输出描述 
对于每一个测试点，在一行上输出一个整数，代表不同的摆放方式数量。如果无法将魔法阅读桌放入阅读室，那么输出 0 。 样例输入 1 3 1 2 2 样例输出 4 提示 对于第一个测试点，已经在题目中加以解释。 对于第二个测试点，无法将魔法桌放入阅读室。

样例输入
2
3 1 2 2
1 2 3 7

样例输出
4
0

提示
对于第一个测试点，已经在题目中加以解释。

对于第二个测试点，无法将魔法桌放入阅读室。


## 第三题
### 题目描述：
小红有一棵由 n 个节点、 n - 1 条无向边构成的树，每条边的权值为 wi。

定义树上两个点 (u,v) 的权值为，从 u 到 v 的简单路径上，全部边权的异或和，特别的，当 u 和 v 为同一个点时，权值为 0 。

小红会提出 q 次询问，每次询问要求计算有多少个点到节点 u 的权值恰好为 k 。

树是指这样的一张图，其上的任意两个点都连通，且不存在环。

简单路径是指两个节点之间的一条路径，其不包含任何重复的节点。也就是说，在简单路径上，每个节点只能出现一次。



输入描述
第一行输入两个整数 n,q( 1≤n , q≤105)，分别表示节点总数和询问次数。

此后 n-1 行，第 i 行输入三个整数 ui , vi 和 wi（ 1≤ui , vi≤n ; ui≠vi ; 0≤w≤260 ）表示树上第 i 条边连接节点 ui 和 vi 且边权为 wi 。保证树联通，没有重边。

此后 q 行，每行输入两个整数 u,k(1≤u≤n,0≤k≤260)代表被询问的节点和限定。

输出描述
对于每一个询问，在一行上输出一个整数，代表到节点 u 的权值恰好为 k 的节点数量。


样例输入
3 2
1 2 2
1 3 3
1 0
2 2

样例输出
1
1

提示
对于第一个询问，只有 1 号结点到 1 号结点的路径异或和为 0。

对于第二个询问，只有 1 号结点到 2 号结点的路径异或和为 2。

# 海康威视

2个小时：25道单选+10道多选+2道编程

## 第一道：字符串去重

编写一个方法，对只有小写字母的字符串进行去重，并保持字母在字符串中首次出现的顺序。
输入描述
输入一串带重复字符的字符串，输出第一次出现的字符的字符串

输出描述
对只有小写字母的字符串进行去重并输出

样例输入
hikvision

样例输出
hikvson

### 代码
```java
import java.util.LinkedHashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        // 创建一个扫描器对象获取输入
        Scanner scanner = new Scanner(System.in);
        
        // 获取输入的字符串
        String input = scanner.nextLine();
        
        // 调用去重方法并打印输出
        System.out.println(removeDuplicates(input));
        
        // 关闭扫描器
        scanner.close();
    }

    // 去除字符串中的重复字符并保持首次出现顺序
    public static String removeDuplicates(String input) {
        // 创建一个有序的Set来存储字符，LinkedHashSet保持插入顺序
        Set<Character> charSet = new LinkedHashSet<>();
        
        // 遍历输入字符串，将每个字符放入set中
        for (char ch : input.toCharArray()) {
            charSet.add(ch);
        }

        // 将Set中的字符拼接为字符串
        StringBuilder result = new StringBuilder();
        for (char ch : charSet) {
            result.append(ch);
        }

        return result.toString();
    }
}

```

### 代码说明

1. 使用 `LinkedHashSet` 保证字符按照插入顺序存储，同时自动去重。
2. 遍历输入字符串，将每个字符插入 `LinkedHashSet`，如果字符已经存在，`Set` 会自动处理重复字符。
3. 最后将 `Set` 中的字符拼接成字符串并返回

### 第二题 SQL 查找

### 题目描述

数据库-每个用户每周的活跃天数

有如下表  user_login 

date           user_id            time

20230101     1           2023-01-01 09:01:00

20230101     1           2023-01-01 11:02:00

20230101     2           2023-01-02 10:08:00

20230102     2           2023-01-02 15:05:00

求每个用户每周的活跃天数

输入描述
建表及插入数据

输出描述
查询结果，userid、第几周、活跃天数

示例：
样例输入
CREATE TABLE user_login(date DATE,user_id int ,time DATETIME);

insert into user_login value('20230101',1,'2023-01-01 09:01:00');

insert into user_login value('20230101',1,'2023-01-01 11:02:00');

insert into user_login value('20230102',2,'2023-01-02 10:08:00');

insert into user_login value('20230102',3,'2023-01-02 15:05:00');

样例输出
||||
|-----|-----|-----|
1 | 202301 | 1
2 | 202301 | 1
3 | 202301 | 1


### 代码
```sql
SELECT 
    user_id,
    YEAR(date)*100 + FLOOR((DAYOFYEAR(date)-1)/7)+1 AS week_number,
    COUNT(DISTINCT date) AS active_days
FROM 
    user_login
GROUP BY 
    user_id, week_number;
```


### 代码解释

1. **计算周编号：**
    
    - `YEAR(date)*100`：获取日期的年份并乘以 100，以便为周编号预留两位数的位置。
    - `FLOOR((DAYOFYEAR(date)-1)/7)+1`：计算日期在一年中的第几周。`DAYOFYEAR(date)` 获取日期在一年中的第几天，减 1 后除以 7，取整，再加 1 得到周编号。
    - **组合起来**，`YEAR(date)*100 + FLOOR((DAYOFYEAR(date)-1)/7)+1` 得到类似 `202301` 的周编号。
2. **计算活跃天数：**
    
    - `COUNT(DISTINCT date)`：统计每个用户在该周内登录的不同日期数量。
3. **分组：**
    
    - `GROUP BY user_id, week_number`：按照用户和周编号分组，计算每个用户每周的活跃天数。


## TCL

人才测评（自有系统）

英文笔试：一个阅读理解题（一篇文章，7个问题）；一道写作题



## 深信服
> 投递三天后发了笔试邮件

<<<<<<< HEAD
选择题+编程题

4道编程题

第一题：输入一个指纹字符串，判有多少个有效设备
定义指纹规则：间隔出现三次的指纹算是一个有效设备
- 只有一个指纹，比如 `AAAA` , 一个
- 所有指纹都不满足规则，一个

第二题：输入一个字符串，判断是否是有效的域名
给出了域名规则：
- 点分隔
- 中间可以有连字符，但是开头和结尾不能有连字符
- 可以是数字和字母



=======
20/30道选择
4道编程
>>>>>>> 94057db26b2418f208958e92c5345f50b75adf27


## 中国网安

### 人才测评
投递第二天发了人才测评邮件

> 和大部分的人才测评类似

第一部分：言语理解
第二部分：数量计算
第三部分：图形推理

第四和第五部分为性格测试

没有消息了......


## 海信

### 人才测评

投递第二天发了人才测评邮件

和大部分的人才测评类似:

第一部分：言语理解
第二部分：数量计算
第三部分：图形推理

第四和第五部分为性格测试

### 在线笔试
>做完人才测评第二天发了笔试邮件，要求72小时内完成

错过了时间，悲伤......

## 海光信息

### 在线笔试

>投递第二天，无人才测评，直接笔试

时间：60分钟
题型：20单选 + 15多选 + 19道填空题

考察操作系统、Linux相关知识偏多


## 招商银行

> 投递第三天，一块发了人才测评和在线笔试

### 人才测评

和大部分的人才测评类似:

第一部分：言语理解
第二部分：数量计算
第三部分：图形推理

第四和第五部分为性格测试

### 在线笔试

第一部分：30分钟，单选题（涉及Java、面向对象、数据库、编程题）
第二部分：60分钟，三道编程题
- 第一道：签到题（补充代码）
- 第二道：判断输入字符串是否为有效的 IPV4 或 IPV6 地址（补充代码）
- 第三道：将输入的字符串进行逆序输出（自己写代码，并要求使用动态规划）
	比如输入： `Apple banana#`  , 输出：`banana Apple`


## 小红书




## 联想

投递第二天，一块发了人才测评和在线笔试

### 人才测评

联想自有题库，也是 言语理解、数量计算、图形推理、逻辑判断 这几个部分。

### 在线笔试

2个小时，一共两部分

第一部分：单选+多选+填空（一定不要花太多时间）

第二部分：两道编程题

**第一题：**

$N*N$ 的网格，给定 每一个小方格中的矿物数量，求最合适的 位置 $[i, j]$ , 使得 $[i, j],\ \ [i-1,j],\ [i+1, j],\ [i, j-1],\ [i,j+1]$ 的矿物数量最多。

**第二题：**

一台机器的初始热量为 $0$，请规划未来 $N$ 天的生产方式，使得在这 $N$ 天内的收益最大。已知第 $i$ 天进行生产增加的热量为 $a_i$ , 得到的收益为 $b_i$,  如果不进行生产，减少的热量为 $c_i$ .

