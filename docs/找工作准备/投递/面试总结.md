
**目标岗位：后端开发，Java**

## 美团

在线笔试

90分钟：10道选择 + 3道编程


### 第一题

#### 题目描述
小红（R）、小蓝（B）和小绿（G）正在一个字符串上玩捉迷藏。他们所在的位置用对应字母表示，其他位置为空地（\*）或障碍（#）。 
寻找方可以每秒移动一个位置，躲藏方不能移动。当寻找方移动到躲藏方的位置时，躲藏方被认为被找到。但是在过程中，双方均不可以移动到障碍上。 

当一个人作为寻找方，另外两个人作为躲藏方时，只要寻找方找到一个躲藏方即认为游戏胜利。 

请计算三个人分别作为寻找方时，能够使游戏胜利所需的最少时间。 

输入描述 
```
在一行上输入一个仅由 “ *#RGB ” 组成的字符串 ，保证 “ RGB ” 各只出现一次。 
```

输出描述 
```
在一行上输出三个整数，代表小红、小蓝和小绿作为寻找方时，能够获胜的最少时间；如果无法获胜，则直接输出 -1 。 
```

示例 1： 

输入： 
```
R***B**G 
```

输出： 
```
4 3 3
```


这个问题可以看作是一个最短路径问题，其中障碍物“`#`”不可通过，其他位置可以通过。我们需要计算每个人（R、B、G）作为寻找方时，找到其他两个人中的一个所需的最少时间。

使用广度优先搜索（BFS）是解决这个问题的理想方法，因为 BFS 能够在无权图（每一步移动的代价相同）中找到从起点到终点的最短路径。

#### 解决方案：

1. **建模问题**：字符串表示地图，`R`、`B`、`G`分别表示三个人的位置。`*`表示可通过的空地，`#`表示障碍物。
2. **BFS搜索**：我们可以从每个寻找方的位置出发，使用BFS计算从该点到其他两个人位置的最短距离。
3. **最终结果**：对于每个人作为寻找方，取找到两个躲藏方中的最短时间。

#### 步骤：

1. 从输入字符串中分别找到 `R`、`B` 和 `G` 的索引位置。
2. 对于每个寻找方（`R`、`B`、`G`），执行一次 BFS，记录从当前寻找方到其他两个人的最短路径。
3. 取最小的非负路径作为答案。如果找不到任何路径，则输出 `-1`。




#### 代码
```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class HideAndSeek {

    public static void main(String[] args) {
        // 使用 Scanner 读取输入
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();  // 从标准输入读取一行
        scanner.close();  // 关闭输入流

        // 调用 findMinimumTimes 函数，返回三个整数结果
        int[] result = findMinimumTimes(input);

        // 输出结果
        System.out.println(result[0] + " " + result[1] + " " + result[2]);
    }

    // 计算每个人作为寻找方时的最短时间
    public static int[] findMinimumTimes(String map) {
        // 获取各个角色的索引位置
        int R = map.indexOf('R');
        int B = map.indexOf('B');
        int G = map.indexOf('G');

        // 分别计算 R, B, G 作为寻找方时的最短时间
        int rTime = bfs(map, R, B, G);
        int bTime = bfs(map, B, R, G);
        int gTime = bfs(map, G, R, B);

        return new int[] {rTime, bTime, gTime};
    }

    // BFS 函数，计算从 start 开始到 target1 或 target2 的最短距离
    public static int bfs(String map, int start, int target1, int target2) {
        int n = map.length();
        boolean[] visited = new boolean[n];  // 记录已访问的位置
        Queue<int[]> queue = new LinkedList<>();  // 队列用于 BFS，保存当前索引和步数
        queue.offer(new int[]{start, 0});  // {当前位置，距离}

        visited[start] = true;  // 标记起始位置已访问

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int position = current[0];  // 当前索引位置
            int steps = current[1];     // 当前步数

            // 如果当前位置是目标位置之一，则返回步数
            if (position == target1 || position == target2) {
                return steps;
            }

            // 检查左右两个邻居
            if (position - 1 >= 0 && !visited[position - 1] && map.charAt(position - 1) != '#') {
                queue.offer(new int[]{position - 1, steps + 1});
                visited[position - 1] = true;
            }
            if (position + 1 < n && !visited[position + 1] && map.charAt(position + 1) != '#') {
                queue.offer(new int[]{position + 1, steps + 1});
                visited[position + 1] = true;
            }
        }

        // 如果找不到任何目标，则返回 -1
        return -1;
    }
}
```




### 第二题

#### 题目描述
小美有 a 个红砖、b 个蓝砖和 c 个绿砖。每 x 个红砖可以合成 1 个蓝砖，每 y 个蓝砖可以合成 1个绿砖。砖块只能正向合成，不能反向分解。 

一套砖块包含 个红砖、 个蓝砖和 个绿砖。请计算小美最多可以收集多少套砖块。 

输入描述： 每个测试文件均包含多组测试数据。第一行输入一个整数T(1<=T<=100000) 代表数据组数，每组测试数据描述如下： 在一行上输入五个整数 a, b, c, x, y(0<=a, b, c <=1000000000, 1<=x,y<=1000000000)，分别表示红砖、蓝砖、绿砖的数量及合成的比例。 

输出描述： 对于每一组测试数据，在一行上输出一个整数，代表小美最多可以收集到的砖块套数。 

示例： 

输入： 2 1 2 3 4 2 10 2 1 4 2 

输出： 1 2

#### 问题分析：

- **初始资源**：有 `a` 个红砖、`b` 个蓝砖、`c` 个绿砖。
- **合成规则**：
    - 每 `x` 个红砖可以合成 1 个蓝砖。
    - 每 `y` 个蓝砖可以合成 1 个绿砖。
- **目标**：最大化套数 `k`，使得在资源限制和合成规则下，可以收集到 `k` 套砖块。

#### 解题思路：

我们需要计算在合成规则和初始资源的限制下，最大可能的套数 `k`。由于砖块只能正向合成，不能反向分解，我们需要谨慎地计算每一步的资源消耗。

**使用二分查找**：

- **搜索范围**：`[0, 最大可能的套数]`，其中最大可能的套数可以是 `a + b + c`。
- **判断条件**：对于一个中间值 `k`，判断是否能收集到 `k` 套砖块。

**判断函数 `canMake(k)` 的实现**：

1. **计算需要的额外绿砖数**：
    
    - `needGreen = max(0, k - c)`
2. **计算合成绿砖需要的蓝砖数**：
    
    - `totalBlueNeededForGreen = needGreen * y`
3. **计算需要的总蓝砖数**：
    
    - `totalBlueNeeded = k (用于套装) + totalBlueNeededForGreen`
4. **计算需要的额外蓝砖数**：
    
    - `needBlue = max(0, totalBlueNeeded - b)`
5. **计算合成蓝砖需要的红砖数**：
    
    - `totalRedNeededForBlue = needBlue * x`
6. **计算需要的总红砖数**：
    
    - `totalRedNeeded = k (用于套装) + totalRedNeededForBlue`
7. **判断资源是否足够**：
    
    - `totalRedNeeded <= a`

#### 示例计算：

以第一组测试数据 `1 2 3 4 2` 为例：

- 目标套数 `k = 1`：
    
    - `needGreen = max(0, 1 - 3) = 0`
    - `totalBlueNeededForGreen = 0 * 2 = 0`
    - `totalBlueNeeded = 1 + 0 = 1`
    - `needBlue = max(0, 1 - 2) = 0`
    - `totalRedNeededForBlue = 0 * 4 = 0`
    - `totalRedNeeded = 1 + 0 = 1`
    - 判断：`totalRedNeeded (1) <= a (1)`，满足条件，可以收集到 1 套。
- 目标套数 `k = 2`：
    
    - `needGreen = max(0, 2 - 3) = 0`
    - `totalBlueNeededForGreen = 0 * 2 = 0`
    - `totalBlueNeeded = 2 + 0 = 2`
    - `needBlue = max(0, 2 - 2) = 0`
    - `totalRedNeededForBlue = 0 * 4 = 0`
    - `totalRedNeeded = 2 + 0 = 2`
    - 判断：`totalRedNeeded (2) <= a (1)`，不满足条件，不能收集到 2 套。

#### 代码
```java
import java.util.Scanner;

public class BrickSets {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();  // 读取测试数据组数
        while (T-- > 0) {
            long a = scanner.nextLong();  // 红砖数量
            long b = scanner.nextLong();  // 蓝砖数量
            long c = scanner.nextLong();  // 绿砖数量
            long x = scanner.nextLong();  // 合成一个蓝砖所需的红砖数量
            long y = scanner.nextLong();  // 合成一个绿砖所需的蓝砖数量

            // 使用二分查找计算最多可以形成多少套砖块
            long left = 0, right = a + b + c;  // 初始范围
            while (left < right) {
                long mid = left + (right - left + 1) / 2;  // 取中间值，避免溢出
                if (canMake(mid, a, b, c, x, y)) {
                    left = mid;  // 如果能收集到 mid 套，则尝试更多套数
                } else {
                    right = mid - 1;  // 如果不能收集到 mid 套，则减少套数
                }
            }

            // 输出结果
            System.out.println(left);
        }
        scanner.close();
    }

    // 判断是否能够收集到 k 套砖块
    public static boolean canMake(long k, long a, long b, long c, long x, long y) {
        // 需要额外的绿砖
        long needGreen = Math.max(0, k - c);  // 需要合成的绿砖数量
        // 合成绿砖所需的蓝砖
        long totalBlueNeededForGreen = needGreen * y;
        // 需要的总蓝砖数
        long totalBlueNeeded = k + totalBlueNeededForGreen;
        // 需要额外的蓝砖
        long needBlue = Math.max(0, totalBlueNeeded - b);
        // 合成蓝砖所需的红砖
        long totalRedNeededForBlue = needBlue * x;
        // 需要的总红砖数
        long totalRedNeeded = k + totalRedNeededForBlue;

        // 判断红砖是否足够
        if (totalRedNeeded > a) {
            return false;
        }
        return true;
    }
}
```





### 第三题

#### 题目描述

小美正在一张有向但不一定连通的图上玩游戏。这张图包含  n 个点，第 i  个点的权值为 a_i，当小美从  i 移动到 Nexti 时，游戏规则如下：
- 如果 a_Nexti > a_i，小美的金币将增加 x；
- 如果 a_Nexti <= a_i ，小美的金币将增加 y。
小美会提出 q 次询问，每个询问从某个点  u 出发，移动不超过 k 步，最多能获得多少金币。

输入描述：

第一行输入四个整数  n, q, x, y (1<=n, q <= 2* 100000, -1000000<=x, y<=1000000)代表图上点的数量、询问的次数、规则中金币的增加量。

第二行输入 n 个整数 Next1, Next2, ..., Nextn (1<=Nexti <=n)  表示第  个节点下一步的位置。
第三行输入  n 个整数 a_1, a_2, ... , a_n (1<=a_i<=1000000) ，表示第  i 个节点的权值。
此后 q  行，每行输入两个整数  u, k (1<=u<=n,1<=k<=1000000000)代表一次询问的起始点和步数限制。


输出描述：
对于每一次询问，在一行上输出一个整数，代表最多能获得的金币数量。


示例：
输入：
```
4 5 -2 3
2 3 4 1
5 10 3 2
1 1
1 2
1 4
2 4
2 7
```
输出：
```
0
1
4
6
8
```

说明：
对于示例：
对于第一次询问，走一步会扣除  2金币，但是可以选择站在原地不走；
对于第二次询问，走一步时金币数量减至  -2，走两步金币数量变更为  -2+3=1。


#### 问题分析

- **关键问题**：当步数 kkk 较小时，我们需要精确地计算在有限步数内能够获得的最大金币数。之前的代码在处理环时，直接使用了环的总金币数和最大子段和，没有考虑剩余步数的限制，导致结果不准确。
    
- **解决方案**：为了准确计算在剩余步数内能够获得的最大金币数，我们需要在进入环后，模拟最多  $\min(k, 2 \times \text{环的长度})$ 步的移动。这是因为在环内，最坏情况下，我们需要遍历两次环才能找到最大的子段和。

#### 代码

```java
import java.util.*;

public class XiaoMeiGame {
    static int n, q;
    static long x, y;
    static int[] Next;
    static int[] a;
    static int[] status;  // 0: 未访问, 1: 访问中, 2: 已访问
    static int[] step;    // step[node]: 到达节点的步数
    static long[] coins;  // coins[node]: 到达节点的累计金币数
    static int[] cycleId; // cycleId[node]: 节点所属的环的编号
    static int[] cyclePos;// cyclePos[node]: 节点在环中的位置
    static List<List<Integer>> cycles = new ArrayList<>();
    static List<Long> cycleTotalCoins = new ArrayList<>();
    static List<Integer> cycleLength = new ArrayList<>();
    static List<long[]> cycleGains = new ArrayList<>();

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        q = sc.nextInt();
        x = sc.nextLong();
        y = sc.nextLong();
        Next = new int[n];
        a = new int[n];
        for (int i = 0; i < n; i++) {
            Next[i] = sc.nextInt() - 1;  // 调整为从0开始的索引
        }
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        status = new int[n];
        step = new int[n];
        coins = new long[n];
        cycleId = new int[n];
        cyclePos = new int[n];
        Arrays.fill(cycleId, -1);

        // 预处理
        for (int i = 0; i < n; i++) {
            if (status[i] == 0) {
                dfs(i, 0, 0, new HashMap<>());
            }
        }

        // 读取查询并输出结果
        for (int i = 0; i < q; i++) {
            int u = sc.nextInt() - 1;  // 调整为从0开始的索引
            long k = sc.nextLong();
            long ans = getMaxCoins(u, k);
            System.out.println(ans);
        }
    }

    // 深度优先搜索，寻找环并预处理
    static void dfs(int u, int currStep, long currCoins, Map<Integer, Integer> map) {
        status[u] = 1;
        step[u] = currStep;
        coins[u] = currCoins;
        map.put(u, currStep);

        int v = Next[u];
        long gain = (a[v] > a[u]) ? x : y;
        if (status[v] == 0) {
            dfs(v, currStep + 1, currCoins + gain, map);
        } else if (status[v] == 1) {
            // 找到一个环
            List<Integer> cycle = new ArrayList<>();
            List<Long> gains = new ArrayList<>();
            long totalCoins = 0;

            int node = v;
            do {
                int nextNode = Next[node];
                long edgeGain = (a[nextNode] > a[node]) ? x : y;
                totalCoins += edgeGain;
                gains.add(edgeGain);
                cycle.add(node);
                cycleId[node] = cycles.size();
                node = nextNode;
            } while (node != v);

            cycles.add(cycle);
            cycleTotalCoins.add(totalCoins);
            cycleLength.add(cycle.size());
            cycleGains.add(gains.stream().mapToLong(Long::longValue).toArray());
        }
        // 已访问完节点u
        status[u] = 2;
    }

    // 计算查询的最大金币数
    static long getMaxCoins(int u, long k) {
        long maxCoins = 0;
        int currNode = u;
        long currCoins = 0;
        long steps = 0;
        Map<Integer, Long> visited = new HashMap<>();
        while (steps < k && !visited.containsKey(currNode)) {
            visited.put(currNode, steps);
            int nextNode = Next[currNode];
            long gain = (a[nextNode] > a[currNode]) ? x : y;
            currCoins += gain;
            steps++;
            currNode = nextNode;
            maxCoins = Math.max(maxCoins, currCoins);
            if (cycleId[currNode] != -1) {
                break;
            }
        }
        if (steps == k || cycleId[currNode] == -1) {
            return maxCoins;
        }
        // 处理环
        int cid = cycleId[currNode];
        int len = cycleLength.get(cid);
        long[] gains = cycleGains.get(cid);
        long totalCycleGain = cycleTotalCoins.get(cid);
        long remainingSteps = k - steps;

        // 模拟环内移动，最多遍历2次环，避免时间过长
        int maxSimulateSteps = (int) Math.min(remainingSteps, 2 * len);
        long tempCoins = currCoins;
        int tempNodeIndex = -1;
        for (int i = 0; i < cycles.get(cid).size(); i++) {
            if (cycles.get(cid).get(i) == currNode) {
                tempNodeIndex = i;
                break;
            }
        }
        for (int i = 0; i < maxSimulateSteps; i++) {
            int idx = (tempNodeIndex + i) % len;
            tempCoins += gains[idx];
            maxCoins = Math.max(maxCoins, tempCoins);
        }
        // 如果剩余步数大于模拟的步数且环的总增益为正，可以通过完整循环获得更多金币
        if (remainingSteps > maxSimulateSteps && totalCycleGain > 0) {
            long cyclesCount = (remainingSteps - maxSimulateSteps) / len;
            tempCoins += cyclesCount * totalCycleGain;
            maxCoins = Math.max(maxCoins, tempCoins);
        }
        return maxCoins;
    }
}
```

#### 代码说明

1. **在 `dfs` 函数中**：
    
    - 记录了每个环的增益数组 `gains`，用于后续计算最大金币数。
2. **在 `getMaxCoins` 函数中**：
    
    - **步骤 1**：在进入环之前，逐步移动，并记录累计金币数 `currCoins` 和已访问节点，直到步数用完或进入环。
    - **步骤 2**：如果在步数用完之前进入了环，模拟在环内的移动。
        - **模拟步数**：为了保证效率，最多模拟 min⁡(剩余步数,2×环的长度)\min(\text{剩余步数}, 2 \times \text{环的长度})min(剩余步数,2×环的长度) 步。
        - **模拟过程**：从当前节点开始，按照环的顺序累加金币数，并更新 `maxCoins`。
    - **步骤 3**：如果剩余步数超过了模拟的步数，并且环的总增益为正，那么可以通过完整循环环来获得更多金币。
        - 计算可以完整循环的次数，并累加相应的金币数。


过了30%

## 小米

90分钟：24道单选+1道双选+2道编程

### 第一道：背包问题

题目描述：
小明正在整理他的玩具，他遇到了一道有趣的装箱问题：他有一个容量为N的箱子，并且有n个大小为a[i]的玩具。除了这n个玩具外，还有c个大小均为1的填充物，它们是小明参加各种活动的纪念品，正好可以拿来填充缝隙。他的任务是确定是否可以选其中一些玩具（填充物也包含在内）放入箱子中，恰好装满箱子，而不留下任何空隙。当然，他也可以选择全部用填充物来填满整个箱子（如果填充物足够多的话），也即装满一箱纪念品，小明也觉得很棒！

输入描述
第一行1个整数T，表示数据组数。

对于每组数据：

第一行包含三个整数N和n和c，分别表示箱子的容量和玩具的数量以及填充物数量。

第二行包含n个整数a[1],a[2],...,a[n]，分别表示这N个玩具的大小。

1≤T≤100, 1≤n≤500, 1≤N,c,a[i]≤1000

输出描述
输出T行分别表示每组数据答案。

对每组数据，输出一行，如果可以恰好装满箱子，输出 YES；否则，输出 NO。

样例输入：
2
10 4 1
2 3 5 7
10 1 3
6

样例输出：
YES
NO

提示
对第一组样例：

箱子的容量是 10，玩具的大小分别为 2、3、5 和 7。
其中一种可行的方法为：玩具 2、3 和 5 加起来正好是 10，所以可以恰好装满箱子，因此输出 YES。

对第二组样例：

只有一个玩具，大小为6，三个大小为1的填充物，全放进去也只有9的大小，无法填满。


### 第二道

请使用Java编程解决下面问题
题目描述：
小明喜欢解决各种数学难题。一天，他遇到了一道有趣的题目：他需要帮助他的朋友们完成一个排序任务。小明得到两个长度为 n 的数组a[]和b[]。他可以在两个数组对应位置进行交换，即选定一个位置i，交换a[i]和b[i]。他可以进行任意次交换（包括0次），他想知道按最优策略来是否可以达成让至少一个数组，a[]或者b[]，变得有序。有序即数组单调不减（升序）或者单调不增（降序）均可。

形式化地，给定两个长度为n的数组a[]和b[]。你可以任选一个位置i交换a[i]和b[i]，可以进行任意多次这样的操作。你的目标是判断是否能够通过这些操作使得至少一个数组变得有序（升序或降序）。

输入描述
第一行一个整数T，表示数据组数。

对于每组数据：

第一行包含一个整数n，表示数组的长度。

第二行包含n个整数a1,a2,...,an。

第三行包含n个整数b1,b2,...,bn。

1≤T≤100，1≤n≤10000，1≤ai,bi≤10000。

输出描述
输出T行分别表示每组数据答案。

对每组数据，如果能够通过交换操作使至少一个数组变得有序，输出 YES；否则，输出 NO。

样例输入
2
5
1 3 5 2 4
5 2 3 4 1
7
1 2 3 4 3 2 1
4 3 2 1 2 3 4

样例输出
YES
NO

提示
第一组数据：

在这个样例中，其中一种可行的方法为：通过交换第2、3、4个位置，我们可以使数组 a变成升序：1 2 3 4 4

第二组数据：

无论如何都无法让任何一个数组变得有序

## 携程集团

2个小时：4道编程题

### 第一题：dfs？
#### 题目描述
一个 n * m 的网格图 ，左上角为 (0, 0)，右下角为 (n-1, m-1)，格子 (i, j) 有价值为 a[i][j] = j + i * m 的宝物。

游游从左上角 (0,0) 为起点，每一步可以走到上下左右四个方向的相邻格子。

每到达一个格子，就能获取价值为 a[i][j]  宝物。需要注意的是，在到达某个格子获取宝物后，这个格子的宝物会在 游游离开这个格子之后 再次刷新。

现在给出一个整数 k，表示游游最多走  k 步。

问：游游最多能获得多少价值的宝物？

输入描述
第一行包含一个整数 q，表示询问个数。

接下来 q 行，每行三个整数 n m k (1<=n, m, k<=10000, n+m >=2)，表示矩阵大小和限制步数。

输出描述
输出包含 q 行，每行一个整数，表示每次询问的结果。

示例
输入
1
2 2 5
输出
12

说明：
```
2*2 的网格图 ，其中 a[0][0]  =0, a[0][1]=1. a[1][0]=2. a[1][1]=3.
因为k=5, 只能走5步，
最优方案：（0, 0）->(1,0)->(1,1)->(1.0)->(1,1)->(1,0)

宝物总和是 12
```

### 核心问题：

- **步数限制**：游游只能走 `k` 步，因此应当利用这些步数，通过某些高价值格子反复来回获取宝物。
- **不需要走新的路径**：游游在步数有限的情况下，可以通过来回走动在同一个格子上获取更多宝物值，而不是一直走新路径。

### 解决方案：

我们可以使用广度优先搜索（BFS），并在 `k` 步内找到最多能够访问的格子，同时每次访问格子时都累加宝物值。

### 重新设计的BFS算法：

1. **队列**：每个队列中的元素包含当前的位置 `(x, y)`，已经走过的步数，以及当前收集到的宝物总价值。
2. **广度优先搜索**：每次从当前格子向四个方向扩展，每次访问到一个新格子时，累加宝物值。并且游游可以重复访问某些格子，从而获取更多的宝物值。

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class TreasureCollector {

    // 定义方向数组，分别表示上下左右移动
    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    // 计算格子的宝物价值
    private static int getValue(int i, int j, int m) {
        return j + i * m;
    }

    // 使用BFS来计算游游在最多 k 步内能够获取的最大宝物值
    private static int getMaxTreasure(int n, int m, int k) {
        // BFS队列，存储当前位置及已走的步数和当前获得的宝物值
        Queue<int[]> queue = new LinkedList<>();
        // 初始位置为 (0, 0)，步数为 0，初始宝物价值为 getValue(0, 0)
        queue.offer(new int[]{0, 0, 0, getValue(0, 0, m)}); // 格式为 [x, y, steps, currentTreasure]
        int maxTreasure = 0;

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0];
            int y = current[1];
            int steps = current[2];
            int currentTreasure = current[3];

            // 更新最大宝物值
            maxTreasure = Math.max(maxTreasure, currentTreasure);

            // 如果已经达到最大步数，停止搜索
            if (steps == k) continue;

            // 向四个方向移动
            for (int[] direction : DIRECTIONS) {
                int newX = x + direction[0];
                int newY = y + direction[1];

                // 判断是否越界
                if (newX >= 0 && newX < n && newY >= 0 && newY < m) {
                    // 每次到达新格子时，宝物值累加
                    queue.offer(new int[]{newX, newY, steps + 1, currentTreasure + getValue(newX, newY, m)});
                }
            }
        }

        return maxTreasure;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        int q = scanner.nextInt();  // 输入的询问个数
        for (int i = 0; i < q; i++) {
            int n = scanner.nextInt();  // 矩阵行数
            int m = scanner.nextInt();  // 矩阵列数
            int k = scanner.nextInt();  // 最大步数

            // 计算最大宝物价值
            int result = getMaxTreasure(n, m, k);
            System.out.println(result);
        }
        
        scanner.close();
    }
}
```


过了 26% ...

### 第二题：贪心

n个数字 构成了一个可重集合，进行以下操作：
每一次操作你都可以任选集合中 最大值-最小值<=k 的 m 个数字，然后删去这 m 个数字中的最小值，并把其他的数字放回集合中。
若无法选出符合条件的  m个数，则无法继续操作。

你可以无限次进行这个操作，直到没法操作为止。

要使得最后留下的数最少，请求出进行上面的操作后留下的最少的数字数量。

输入描述：第一行三个整数n，m，k。第二行n个整数代表初始可重集合中的元素a_i。
输出描述：一个整数，代表操作后留下的最少的数字数量。
示例1输入：
4 3 3
1 2 3 6
示例1输出：
3
示例1说明：最多只能进行一次操作，即选中 1 2 3，然后删去 1。
剩余的数为 2 3 6，由于最大值和最小值之差大于 3，因此无法继续操作。


#### 题目解析：

- **操作规则**：每次你可以选择集合中最大值与最小值差值小于等于 `k` 的 `m` 个数，删除其中的最小值，剩下的 `m-1` 个数回到集合中。
- **目标**：进行尽可能多的操作，最后留下最少的数字。

### 思路：

1. **贪心策略**：每次尽可能选择符合条件的数字，并删除最小值。为了实现这个目标，数组中的数字需要排序，这样我们可以容易地找到符合条件的一组数字进行删除操作。
    
2. **分组操作**：我们从排序后的数组中选择连续的 `m` 个数字，确保这些数字的最大值和最小值的差小于等于 `k`。如果找到这样的组，就执行删除最小值的操作，并继续尝试处理剩下的数组。
    
3. **终止条件**：当无法找到符合条件的 `m` 个数时，结束操作，输出剩余的数字数量。
    

### 贪心算法步骤：

1. **排序**：将数组从小到大排序，便于后续进行分组处理。
2. **遍历数组**：每次从排序后的数组中找到符合条件的一组 `m` 个数（最大值与最小值之差小于等于 `k`）。
3. **删除最小值**：从当前组中删除最小值，并将剩余的 `m-1` 个数放回集合中。
4. **继续处理**：重复这个过程直到无法再找到符合条件的组。


```java
import java.util.*;

public class MinimizeRemainingNumbers {
    public static int minimizeRemaining(int n, int m, int k, int[] nums) {
        // 先将数组排序
        Arrays.sort(nums);

        // 用于记录已处理的元素索引
        boolean[] removed = new boolean[n];
        int remaining = n;

        // 遍历整个数组，尝试找到符合条件的组
        for (int i = 0; i <= n - m; i++) {
            // 如果当前数字已经被删除，跳过
            if (removed[i]) continue;

            // 判断从 i 开始的 m 个数是否符合条件
            if (nums[i + m - 1] - nums[i] <= k) {
                // 符合条件，将最小值删掉
                removed[i] = true;
                remaining--;  // 删除最小值，减少一个剩余的数字
            }
        }

        return remaining;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 输入数据
        int n = sc.nextInt();  // 数字个数
        int m = sc.nextInt();  // 每次选择的数字个数
        int k = sc.nextInt();  // 最大值和最小值之差的限制
        int[] nums = new int[n];

        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt();  // 输入数字
        }

        // 计算并输出结果
        int result = minimizeRemaining(n, m, k, nums);
        System.out.println(result);

        sc.close();
    }
}
```

### 优化思路：

1. **双指针方法**：我们可以使用双指针（滑动窗口）来优化遍历过程。在排序的数组中，使用一个窗口来维护符合条件的 `m` 个数的范围，这样可以减少重复的判断，提升效率。
    
    - 左指针 `left` 指向当前窗口的起始位置，右指针 `right` 向右扩展，直到窗口中的最大值和最小值之差大于 `k`。
    - 当窗口内的数字个数大于等于 `m` 时，可以进行删除操作，移除窗口中的最小值（即 `left` 指针指向的数字），然后更新窗口。
2. **一次遍历**：我们可以在一次遍历中通过滑动窗口的方式，确定能够删除的数字，优化代码的时间复杂度。
### 可以优化的方向：

1. **减少窗口管理的复杂度**：当前的双指针滑动窗口已经将遍历过程压缩到了 `O(n)`，但每次满足条件后，我们会立即删除一个数字并移动左指针。我们可以改为直接跳过一段已经确定的符合条件的数字，避免不必要的重复操作。
    
2. **减少删除操作次数**：可以通过直接从窗口的末尾往回检查，找到能够删除的最小值段，而不是每次删除一个最小值。

```java
import java.util.*;

public class MinimizeRemainingNumbers {
    public static int minimizeRemaining(int n, int m, int k, int[] nums) {
        // 先将数组排序
        Arrays.sort(nums);

        int remaining = n;  // 剩余的数字个数
        int left = 0;  // 左指针

        while (left <= n - m) {  // 保证至少能选出 m 个数
            int right = left + m - 1;  // 找到符合条件的 m 个数的末尾
            // 检查这 m 个数的最大值和最小值之差是否小于等于 k
            if (nums[right] - nums[left] <= k) {
                remaining--;  // 删除最小值
                left++;  // 移动左指针
            } else {
                left++;  // 当前不满足条件，直接跳过
            }
        }

        return remaining;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 输入数据
        int n = sc.nextInt();  // 数字个数
        int m = sc.nextInt();  // 每次选择的数字个数
        int k = sc.nextInt();  // 最大值和最小值之差的限制
        int[] nums = new int[n];

        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt();  // 输入数字
        }

        // 计算并输出结果
        int result = minimizeRemaining(n, m, k, nums);
        System.out.println(result);

        sc.close();
    }
}
```

### 第三题：二分

游游有n 个人组成的合唱团，第 i 个人的能力值为 $a_i$  。

现在将 n 个人排成一排，游游有 k 次训练的机会，让不超过 $l$ 个连续的人能力人变为任意值。

如果合唱团的实力是所有人能力值的最小值。你可以帮助游游求出合唱团的实力的最大值是多少吗？

输入描述
第一行三个整数 n, m, k,  表示人数,训练次数,每次训练的最大长度
第二行个整数 $a_i$ ,表示第 i 个人的能力值

输出描述
一个整数表示合唱团实力最大值。

示例：
输入：
```
8 2 3
7 4 11 2 1 4 7 5
```
输出：
```
5
```

说明：让区间[2,4],[4,6]变成11，这样可以使最小值为5



```java
import java.util.Scanner;

public class ChorusPower {

    // 判断是否能够通过不超过 k 次训练将最小的实力提升到 target
    public static boolean canAchieveMinimum(int[] a, int n, int k, int l, int target) {
        int needed = 0;  // 记录所需训练次数
        int i = 0;
        
        while (i < n) {
            if (a[i] < target) {
                needed++;
                i += l;  // 跳过 l 个位置
            } else {
                i++;  // 当前值满足条件，继续下一个
            }
            if (needed > k) {  // 如果已经超过可用训练次数，返回 False
                return false;
            }
        }
        
        return needed <= k;
    }

    // 二分搜索合唱团实力的最大值
    public static int maxChorusPower(int n, int k, int l, int[] a) {
        int left = Integer.MAX_VALUE;
        int right = Integer.MIN_VALUE;

        // 找到数组中的最小值和最大值，作为二分查找的边界
        for (int value : a) {
            left = Math.min(left, value);
            right = Math.max(right, value);
        }
        right++;  // 由于二分查找的右边界需要是一个不可行的值，故设为 right + 1

        // 二分查找
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (canAchieveMinimum(a, n, k, l, mid)) {
                left = mid;  // 可以实现，尝试更大的值
            } else {
                right = mid - 1;  // 不可以实现，尝试更小的值
            }
        }
        
        return left;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 读取输入
        int n = sc.nextInt();  // 队伍人数
        int k = sc.nextInt();  // 可进行的训练次数
        int l = sc.nextInt();  // 每次训练影响的人数
        int[] a = new int[n];  // 每个人的实力值
        
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();  // 读取每个人的实力
        }
        
        // 计算并输出结果
        int result = maxChorusPower(n, k, l, a);
        System.out.println(result);

        sc.close();
    }
}

```

### 第四题：二分

n名员工，这n名员工的初始位置在a[i]，办公室的位置在p。

有k个通行证，这k个通行证的位置在b[i]，每个位置有且只有一个通行证。这个位置的通行证如果被拿走了，这里就没有通行证了，其他员工无法在这个位置拿到通行证了。

员工上班之前必须拿到通行证，每个通行证只能供一个人使用，一个位置上最多只有一个通行证。员工的初始位置可能和通行证的初始位置相同。

每名员工必须有通行证才能进办公室(员工先要去b[i]拿到通行证，然后再去办公室地点p)，员工移动一单位距离需要花费一单位时间。

请问这个员工都达到办公室的最短时间是多少。

输入描述：
第一行三个整数n,k,p。
第二行n个整数a[i]。
第三行k个整数b[i]
输出描述:
2 4 50
20 100
60 10 40 80
输出：
50
说明：
位置在20的人应该拿走位于40的通行证，然后将其带到位于位置在50的办公室。他花了30单位时间的时间。位置在100的人可以拿起位置在80的通行证，并随身去办公室。 他花了50单位时间。 因此，在50单位时间后，每个人都在办公室。

这是一个匹配问题，涉及到员工从他们的初始位置出发，先去通行证的地点拿到通行证，然后再前往办公室。目标是找到最优的匹配方案，使所有员工都能以最短的时间到达办公室。

### 问题分解：

1. 每个员工 `a[i]` 需要先前往某个通行证 `b[i]` 的位置，拿到通行证后，再去办公室 `p`。
2. 每个员工去取通行证和再去办公室的总时间为：`|a[i] - b[j]| + |b[j] - p|`，即从员工的位置到通行证的位置的时间，加上从通行证位置到办公室的时间。
3. 我们需要为每个员工找到一个最优的通行证分配方案，使得所有员工到达办公室的最大时间最小化。

### 思路：

1. **排序**：将员工的位置 `a[i]` 和通行证的位置 `b[i]` 都进行排序，这样可以减少不必要的匹配尝试。
2. **二分查找**：使用二分法来猜测一个最小的可能的最大时间 `t`，然后判断是否存在一种分配方案，使得所有员工在 `t` 时间内到达办公室。
3. **双指针匹配**：使用双指针方法进行匹配，判断当前的猜测时间 `t` 是否足够让所有员工到达办公室。

```java
mport java.util.Arrays;
import java.util.Scanner;

public class MinimizeMaxTime {

    // 判断给定的时间限制 t 下，是否可以让每个员工在时间 t 内拿到通行证并到达办公室
    public static boolean canReachWithinTime(int[] employees, int[] passes, int n, int k, int p, int t) {
        int j = 0;  // 用来遍历通行证的位置
        
        // 尝试为每个员工分配通行证
        for (int i = 0; i < n; i++) {
            // 找到一个符合时间限制的通行证
            while (j < k && Math.abs(employees[i] - passes[j]) + Math.abs(passes[j] - p) > t) {
                j++;
            }
            
            // 如果没有找到符合时间限制的通行证，返回 false
            if (j >= k) {
                return false;
            }
            
            j++;  // 分配当前通行证给员工 i
        }
        
        return true;  // 所有员工都能在时间 t 内拿到通行证并到达办公室
    }

    // 计算员工们到达办公室所需的最短时间
    public static int minimizeMaxTime(int n, int k, int p, int[] employees, int[] passes) {
        // 将员工的位置和通行证的位置都排序
        Arrays.sort(employees);
        Arrays.sort(passes);
        
        // 二分查找最大时间 t 的范围
        int left = 0;
        int right = Integer.MAX_VALUE;
        
        while (left < right) {
            int mid = (left + right) / 2;
            if (canReachWithinTime(employees, passes, n, k, p, mid)) {
                right = mid;  // 能实现，尝试更短的时间
            } else {
                left = mid + 1;  // 不能实现，增加时间限制
            }
        }
        
        return left;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 读取输入
        int n = sc.nextInt();  // 员工人数
        int k = sc.nextInt();  // 通行证数量
        int p = sc.nextInt();  // 办公室的位置
        int[] employees = new int[n];  // 员工初始位置
        int[] passes = new int[k];  // 通行证位置

        for (int i = 0; i < n; i++) {
            employees[i] = sc.nextInt();  // 员工位置
        }

        for (int i = 0; i < k; i++) {
            passes[i] = sc.nextInt();  // 通行证位置
        }

        // 计算并输出结果
        int result = minimizeMaxTime(n, k, p, employees, passes);
        System.out.println(result);

        sc.close();
    }
}
```



## Vivo
先做了人才测评, 9.12日晚发了笔试邮件，9.13下午3点笔试
题目类型：6道单选，4道多选，3道编程题

### 第一道编程题：签到题
#### 题目描述
Vivo项目组新老员工分组完成任务，员工数组staff，其中0表示新员工，1表示老员工
分组规则如下：
1、一个小组至多3个员工
2、一个小组中最多有1个老员工
3、如果一个小组中有1个老员工，那么这组最多有2个员工

求最小的分组数。


输入描述：
输入员工数组 staff，元素只包含0,1
输出描述：
输出一个整数，表示最小分组数



### 第二道编程题：滑动窗口
#### 题目描述
你是一名手机应用开发工程师，需要分析应用在手机上的内存使用情况。你有一个数组 memoryUsage，其中 memoryUsage[i] 表示应用在第 i 秒的内存使用量（以MB为单位）。为了评估应用的稳定性，你需要找出每个连续 k 秒内的内存使用量的波动范围（即最大值与最小值的差值），并返回这些波动范围。

输入
```
[80, 100, 70, 90, 60, 85, 75, 95, 110],4
```

输出 
```
[30,40,30,30,35,35]
```

#### 答案

使用滑动窗口技术来高效地计算每个连续 k 秒内的内存使用量的波动范围。
使用双端队列（Deque）来维护当前窗口中的最大值和最小值。这样可以在 O(n) 时间复杂度内完成计算，其中 n 是数组的长度。

```java
import java.util.Deque;
import java.util.LinkedList;

public class MemoryUsageAnalysis {
    public static void main(String[] args) {
        int[] memoryUsage = {80, 100, 70, 90, 60, 85, 75, 95, 110};
        int k = 4;
        int[] result = calculateFluctuationRange(memoryUsage, k);
        for (int r : result) {
            System.out.print(r + " ");
        }
    }

    public static int[] calculateFluctuationRange(int[] memoryUsage, int k) {
        int n = memoryUsage.length;
        if (n == 0 || k > n) return new int[0];

        int[] result = new int[n - k + 1];
        Deque<Integer> maxDeque = new LinkedList<>();
        Deque<Integer> minDeque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            // Remove indices that are out of the current window
            while (!maxDeque.isEmpty() && maxDeque.peekFirst() <= i - k) {
                maxDeque.pollFirst();
            }
            while (!minDeque.isEmpty() && minDeque.peekFirst() <= i - k) {
                minDeque.pollFirst();
            }

            // Maintain the decreasing order for maxDeque
            while (!maxDeque.isEmpty() && memoryUsage[maxDeque.peekLast()] <= memoryUsage[i]) {
                maxDeque.pollLast();
            }
            // Maintain the increasing order for minDeque
            while (!minDeque.isEmpty() && memoryUsage[minDeque.peekLast()] >= memoryUsage[i]) {
                minDeque.pollLast();
            }

            maxDeque.offerLast(i);
            minDeque.offerLast(i);

            // Calculate the result for the current window
            if (i >= k - 1) {
                int max = memoryUsage[maxDeque.peekFirst()];
                int min = memoryUsage[minDeque.peekFirst()];
                result[i - k + 1] = max - min;
            }
        }
        return result;
    }
}
```

初始化：
- maxDeque 用于维护当前窗口的最大值的索引。
- minDeque 用于维护当前窗口的最小值的索引。

遍历数组：
- 对于每个元素，首先移除已经超出当前窗口范围的索引。
- 维护 maxDeque 使其保持递减顺序，维护 minDeque 使其保持递增顺序。
- 将当前索引添加到 maxDeque 和 minDeque 中。
- 当 当前索引已经达到至少 k 的窗口大小时，计算当前窗口的最大值和最小值的差值，并将结果存入 result 数组。

输出结果：
- 遍历完成后，result 数组中保存了每个连续 k 秒内的内存使用量的波动范围。


### 第三道编程题：回溯
#### 题目描述
Vivo为回馈粉丝，进行礼品派发活动，不同礼品价格不同，为公平起见，需要将全部的礼品公平的分配到粉丝手中，且每位粉丝拿到的礼品总价格相同。请帮忙确认以下的礼品数量和价格是否可以满足公平的分配原则，可以则返回true，否则返回false。

例如：

价格分别为 5, 4, 1, 3, 2, 3, 2 的礼物是否可以公平分配到4名粉丝手？答案是可以的，按(5)、(2,3)、(2,3)、(1,4)组合，第一位粉丝分配到价格为5的礼物，第二位分配到价格为2和3的礼物，第三位分配到价格为2和3的礼物，第四位分配到价格为1和4的礼物，全部礼物分配完，最后返回true，代表可以公平分配。

程序需要输入的参数是价格数组和粉丝人数（数组元素和粉丝人数均小于1000）


示例：
输入：
```
[5,4,1,3,2,3,2],4
```

输出：
```
true
```

#### 思路

1. 检查是否能分配：
	- 计算所有礼品价格的总和 S。
	- 如果总和 S 不能被粉丝人数 k 整除，则不能公平分配，返回 false。
	- 计算每个粉丝应该得到的礼品总价格，即 targetSum = S / k。
2. 使用回溯算法：
	- 尝试将礼品分配到不同的粉丝，确保每个粉丝的礼品总价格都等于 targetSum。
	- 使用回溯法遍历所有可能的分配方式，确保每个粉丝都能够获得符合条件的礼品组合。
3. 优化：
	- 对礼品价格进行排序，以提高效率，先处理大价格的礼品可以减少回溯的深度。

#### 答案
```java
import java.util.Arrays;

public class FairDistribution {
    public static void main(String[] args) {
        int[] prices = {5, 4, 1, 3, 2, 3, 2};
        int k = 4;
        System.out.println(canDistribute(prices, k));  // 输出: true
    }

    public static boolean canDistribute(int[] prices, int k) {
        int total = Arrays.stream(prices).sum();
        if (total % k != 0) {
            return false;
        }
        int targetSum = total / k;
        int n = prices.length;
        
        // 先排序以优化回溯性能
        Arrays.sort(prices);
        // 如果最大值大于目标总和，不能分配
        if (prices[n - 1] > targetSum) {
            return false;
        }
        
        boolean[] used = new boolean[n];
        return canDistributeHelper(prices, used, 0, k, 0, targetSum);
    }

    private static boolean canDistributeHelper(int[] prices, boolean[] used, int start, int k, int currentSum, int targetSum) {
        if (k == 0) {
            return true;
        }
        if (currentSum == targetSum) {
            // 当前组分配完，开始下一个组
            return canDistributeHelper(prices, used, 0, k - 1, 0, targetSum);
        }

        for (int i = start; i < prices.length; i++) {
            if (!used[i] && currentSum + prices[i] <= targetSum) {
                used[i] = true;
                if (canDistributeHelper(prices, used, i + 1, k, currentSum + prices[i], targetSum)) {
                    return true;
                }
                used[i] = false;
            }
        }
        return false;
    }
}
```


## OPPO 
直接笔试，2个小时 20道单选+3道编程题

### 第一题：贪心

#### 题目描述

小红有一个长度为 n 的数组{a_1, a_2, ......, a_n} ，小红需要执行 k 次操作，操作内容如下：
- 选择一个数组元素 a_i，令 a_i = a_i 按位异或 1
小红想让数组元素之和最大，请你输出这个值。

输入描述:
第一行输入两个整数 n, k 代表数组中的元素数量、操作数量。
第二行输入 n 个整数 代表数组元素。
其中 1<=n<=100000, 1<=k<=1000000000
数组中的每个元素 a_i 满足1<= a_i<=1000000000

输出描述:
在一行上输出一个整数，代表最大的数组元素之和。

示例：
输入：
5 3
1 2 3 4 5

输出
16

#### 思路

这个问题的目标是通过执行最多 kkk 次按位异或操作，让数组的元素之和尽可能大。

按位异或操作 `a_i = a_i 异或 1` 的作用是：如果 `a_i` 是偶数，则将其变为奇数；如果 `a_i` 是奇数，则将其变为偶数。因此：

- 对偶数执行异或操作可以让它增加 1（变成更大的奇数）。
- 对奇数执行异或操作会让它减少 1（变成更小的偶数）。

优化思路：

1. **贪心策略**：
    
    - 如果 a_i​ 是偶数，我们希望对其执行异或操作，这样可以让它增加 1。
    - 如果 a_i​ 是奇数，我们尽量不对其执行异或操作，因为这样会减少它的值。
2. **优先处理偶数**：
    
    - 将数组中的偶数尽可能变为奇数，因为这样可以增加总和。
    - 如果操作次数 k 用完后还有剩余，剩下的操作需要交替对奇数和偶数进行反转。
3. **处理剩余操作**：
    
    - 如果 k 次操作后还有剩余，且剩下的次数是偶数次，那么不需要再改变数组，因为两次操作对同一个数会恢复原值。
    - 如果剩余次数是奇数次，则可以对任意一个元素进行一次异或操作，影响最小的选择是对某个奇数执行一次异或。

算法步骤：

1. 遍历数组，将偶数按位异或，使其变成奇数。
2. 计算剩余的操作次数。
3. 如果剩余操作是奇数次，则对影响最小的元素（奇数）执行一次异或。


#### 答案
```java
import java.util.Scanner;

public class MaximizeArraySum {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 输入 n 和 k
        int n = scanner.nextInt();
        long k = scanner.nextLong();
        
        // 输入数组
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
        // 统计初始的数组总和
        long sum = 0;
        for (int num : arr) {
            sum += num;
        }

        // 遍历数组，处理偶数元素
        for (int i = 0; i < n && k > 0; i++) {
            if (arr[i] % 2 == 0) { // 如果是偶数，执行异或操作
                arr[i] = arr[i] ^ 1; // 使偶数变为奇数
                sum += 1; // 偶数异或后加1，所以总和增加1
                k--; // 执行了一次操作
            }
        }
        
        // 如果剩下的 k 还不为0且是奇数，需要再处理一次异或
        if (k > 0 && k % 2 == 1) {
            // 对最小的元素再执行一次异或操作，选择改变后最小影响的元素
            int minElement = Integer.MAX_VALUE;
            for (int num : arr) {
                minElement = Math.min(minElement, num);
            }
            // 异或操作会让这个最小的元素增减 1
            sum -= minElement; // 先减去当前的最小值
            sum += minElement ^ 1; // 再加上异或 1 后的值
        }
        
        // 输出最大的总和
        System.out.println(sum);
        
        scanner.close();
    }
}

```


>过了60%


#### 代码解析：

1. **输入处理**：我们读取数组的长度 n 和操作次数 k，并初始化数组。
2. **初始总和计算**：在不进行操作的情况下，先计算出数组的总和。
3. **处理偶数**：我们遍历数组，将偶数通过异或 1 变成奇数，并增加总和。
4. **处理剩余操作**：如果剩余的操作次数 kkk 是奇数，那么就选择数组中最小的元素执行一次异或操作，确保对总和的影响最小。
5. **输出结果**：最后输出最大化的数组总和。

复杂度分析：

- **时间复杂度**：O(n)，我们只需遍历数组一遍，来处理所有偶数并计算总和。
- **空间复杂度**：O(1)，只需常数空间来存储几个变量。


### 第二题
#### 题目描述
小红有一个长度为  n 的数组  {a_1, a_2, ..., a_n}。小红可以进行若干次操作，每次操作可以选择一个数p (1<=p<=n-1) ，将数组分成 [1, p] 和 [p+1,n] 两部分，然后分别对这两部分进行反转。
例如，对于数组 [1, 2, 3, 4, 5]，如果 p=2，则操作后的数组为 [2, 1, 5, 4, 3]。
小红想对数组进行若干次操作，然后截取一个非空子数组，使得截取的子数组元素和最大，问最大的元素和是多少。


输入描述
第一行输入一个整数  n (1<=n<=100000)代表数组中的元素数量。
第二行输入 n 个整数 a_1, a_2, ..., a_n (1<=a_i<=1000000000)表示数组元素。

输出描述：
在一行上输出一个整数，代表最大的元素和

示例：
输入：
5
3 4 -5 -1 2
输出：
9


#### 思路

为了充分利用反转操作的潜力，我们需要考虑以下两点：

1. **不进行任何反转的最大子数组和**：即直接使用 Kadane's Algorithm 得到当前数组的最大子数组和。
2. **一次反转后的最大子数组和**：通过反转操作，我们可以优化子数组的和。特别是考虑“前缀”和“后缀”的组合，反转会将前缀和后缀互换，因此我们需要计算可能通过反转获得的更优子数组和。

解决方案：

1. **正向 Kadane's Algorithm**：计算数组的最大子数组和，代表不做任何反转的情况。
2. **反向 Kadane's Algorithm**：计算数组从后往前的最大子数组和，代表进行一次反转后，可以将一些负数移动到后面或前面以优化结果。

我们需要计算出以下几个部分：

- 原始数组中正向的最大子数组和。
- 反向时的前缀和后缀的组合，找出反转后可以获得的最大子数组和。

#### 答案
```java
import java.util.Scanner;

public class MaxSubarraySumWithReverse {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 读取输入的 n
        int n = scanner.nextInt();
        
        // 读取数组
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
        // 计算最大子数组和（不做反转）
        long maxNormal = kadaneMaxSubarraySum(arr);
        
        // 计算可能通过反转获得的最大子数组和
        long maxWithReverse = maxSubarraySumWithReverse(arr);
        
        // 输出最大值
        System.out.println(Math.max(maxNormal, maxWithReverse));
        
        scanner.close();
    }
    
    // Kadane's Algorithm 实现，计算最大子数组和
    public static long kadaneMaxSubarraySum(int[] arr) {
        long currentMax = arr[0];
        long globalMax = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            currentMax = Math.max(arr[i], currentMax + arr[i]);
            globalMax = Math.max(globalMax, currentMax);
        }
        
        return globalMax;
    }
    
    // 计算通过一次反转获得的最大子数组和
    public static long maxSubarraySumWithReverse(int[] arr) {
        int n = arr.length;
        
        // 前缀最大和
        long[] prefixMax = new long[n];
        long currentPrefixSum = 0;
        long maxPrefix = Long.MIN_VALUE;
        
        for (int i = 0; i < n; i++) {
            currentPrefixSum += arr[i];
            maxPrefix = Math.max(maxPrefix, currentPrefixSum);
            prefixMax[i] = maxPrefix;
        }
        
        // 后缀最大和
        long[] suffixMax = new long[n];
        long currentSuffixSum = 0;
        long maxSuffix = Long.MIN_VALUE;
        
        for (int i = n - 1; i >= 0; i--) {
            currentSuffixSum += arr[i];
            maxSuffix = Math.max(maxSuffix, currentSuffixSum);
            suffixMax[i] = maxSuffix;
        }
        
        // 寻找通过一次反转可以得到的最大子数组和
        long maxSumWithReverse = Long.MIN_VALUE;
        
        for (int p = 0; p < n - 1; p++) {
            maxSumWithReverse = Math.max(maxSumWithReverse, prefixMax[p] + suffixMax[p + 1]);
        }
        
        return maxSumWithReverse;
    }
}
```

#### 代码解释：

1. **Kadane's Algorithm**：用于计算数组的最大子数组和，这部分不考虑反转，直接应用 Kadane 算法。
    
2. **maxSubarraySumWithReverse 函数**：
    
    - 计算数组的前缀和后缀最大值。
    - `prefixMax[i]` 表示从数组的开头到第 `i` 个元素的最大子数组和。
    - `suffixMax[i]` 表示从数组的第 `i` 个元素到数组末尾的最大子数组和。
    - 在反转时，我们选择一个位置 `p`，将数组分成前缀 `[1, p]` 和后缀 `[p+1, n]`，分别反转这两部分。为了获得最优解，我们找出某个位置 `p` 使得 `prefixMax[p] + suffixMax[p + 1]` 最大。
3. **比较最大值**：我们取不反转时的最大子数组和 `maxNormal` 和反转后可能获得的最大子数组和 `maxWithReverse` 中的较大值，作为最终的结果。


### 第三题：
#### 题目描述
小红有两个长度为 n 的数组 {a_1, a_2, ..., a_n} 和 {b_1, b_2, ..., b_n} ，定义数组  a和数组 b 的距离为 (a_1-b_1)^2 + (a_2 - b_2)^2 + ... + (a_i - b_i)^2 + ... + (a_n - b_n)^2。
小红最多可以进行 k 次操作，每次操作可以选择数组 a 或数组 b 中的一个元素，将其加一或减一。请问小红最多可以将两个数组的距离缩小到多少。

输入描述：
第一行输入两个整数 n,k (1<=n<=100000, 0<=k<=1000000000) 分别代表数组中的元素数量、最多可以进行的操作次数。
第二行输入  n 个整数a_1, a_2, ..., a_n(1<=a_i<=1000000000)  表示数组 a。
第三行输入  n 个整数b_1, b_2, ..., b_n(1<=b_i<=1000000000)  表示数组 b。

输出描述：
输出一个整数，表示最多可以将两个数组的距离缩小到多少。由于答案可能很大，输出答案对 1000000000+7 取模的结果。

示例：
输入：
5 3
1 2 3 4 5
5 4 3 2 1
输出：
21

#### 思路

1. **初始距离计算**：首先计算初始的距离，即对每一对元素 (ai,bi)(a_i, b_i)(ai​,bi​) 计算 (ai−bi)2(a_i - b_i)^2(ai​−bi​)2 的和。
    
2. **优先减少差距大的项**：我们希望尽量减小那些差值绝对值最大的项的平方值，因此每次操作我们需要选择绝对差值最大的元素进行调整。
    
3. **调整后的差值**：每次对差值最大的项进行调整，将其减少（加1或减1），然后重新计算这个位置的平方差。
    
4. **贪心策略**：每次找到当前最大差值的项，进行一次操作，使得距离尽可能减少。可以使用最大堆（优先队列）来追踪当前最大差值的位置和值。
    
5. **取模计算**：最后结果对 10^9 + 7 取模。
    

具体步骤：

1. 初始化计算每一对元素 a_i​ 和 b_i​ 的差值平方，并计算出总距离。
2. 将每一对元素的差值按绝对值大小放入优先队列。
3. 每次从队列中取出当前绝对差值最大的项，执行一次操作（将其增大或减小1，取决于差值的符号），并更新优先队列中的该项。
4. 重复该操作最多执行 `k` 次。
5. 最后计算出更新后的距离，并对 10^9 + 7 取模。

#### 代码
```java
import java.util.PriorityQueue;
import java.util.Scanner;

public class MinimizeArrayDistance {
    // 模数
    static final long MOD = 1000000000 + 7;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 输入 n 和 k
        int n = scanner.nextInt();
        long k = scanner.nextLong();
        
        // 输入数组 a 和 b
        int[] a = new int[n];
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        for (int i = 0; i < n; i++) {
            b[i] = scanner.nextInt();
        }
        
        // 优先队列，存储绝对差值，最大堆
        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> Integer.compare(Math.abs(y), Math.abs(x)));
        
        // 初始计算距离并将差值放入优先队列
        long initialDistance = 0;
        for (int i = 0; i < n; i++) {
            int diff = a[i] - b[i];
            pq.offer(diff);
            initialDistance += (long) diff * diff;
        }
        
        // 贪心减少距离
        while (k > 0 && !pq.isEmpty()) {
            int diff = pq.poll();
            int newDiff;
            
            if (diff > 0) {
                newDiff = diff - 1;
            } else if (diff < 0) {
                newDiff = diff + 1;
            } else {
                newDiff = 0; // 如果差值为 0，不能再减少了
            }
            
            // 更新总距离
            initialDistance -= (long) diff * diff;
            initialDistance += (long) newDiff * newDiff;
            pq.offer(newDiff);
            
            k--;
        }
        
        // 输出结果，对 MOD 取模
        System.out.println(initialDistance % MOD);
        
        scanner.close();
    }
}
```

并没有完全A


## 小红书

2个小时：20道选择 + 3道编程



### 第一题

#### 题目描述


小红书的第 i 篇文章有一个点赞数 ai 。小红认为，如果两篇不同的文章满足：点赞数通过位异或运算恰好得到 k ，那么这两篇文章是相似文章，即ai xor aj=k 。

现在小红收集到了 n 篇文章的点赞数，请帮助她计算出有多少对 (i,j) 是相似文章。


输入描述
第一行输入两个整数 $n，k(1≤n≤2*105,0≤k≤109)$ 代表文章总数与相似文章判断值。

第二行输入 n 个整数 a1,a2,...,an(0≤ai≤109) 代表每篇文章的点赞数。

输出描述
在一行上输出一个整数，代表相似文章的对数。


样例输入
4 5
1 1 3 4

样例输出
2

提示
可以发现，1 xor 4 = 5 ，那么文章一和四、文章二和四为两对相似文章。


### 第二题：

#### 题目描述： 
小红书总部有一间神秘的魔法阅读室，它四四方方的，三边长为 x,y 和 z ：在三维空间内，我们可以假定它占据了 (0,0,0) 到 (x,y,z) 的空间。有魔法的地方在于，这里面是不存在重力的！这样一来，阅读桌就可以漂浮在任何位置。 

小红书的大家都非常的热爱阅读，特别是在魔法阅读室里！所以，为了搭配魔法阅读室，大家购买了一张魔法阅读桌：这个桌子的体积为 k ，边长可以为任何的正整数。你需要将魔法阅读桌放入魔法阅读室，使得阅读桌的各边平行于对应轴，并且每个角都位于整数坐标上。 在所有可能的边长选取情况下，旋转桌子被视为一种方向，找到全部三种方向里摆放方式数量最多的那种情况的数量之和。例如下图中，在 3*1*2 的空间里有一张边长为 (2,1,1) 的阅读桌，左右方向有 4 种摆放方式，而竖直方向只有 3 种摆放方式，故我们选取左右方向计入答案。 

输入描述 
每个测试文件均包含多个测试点。第一行输入一个整数 T(1≤T≤1000) 代表测试数据组数，每组测试数据描述如下： 第一行输入四个整数 x,y,z 和 k(1≤x,y,z≤1000,1≤k≤109) ，分别代表魔法阅读室的三边长和魔法阅读桌的体积。 除此之外，保证所有的 x 之和，y 之和以及所有的 z 之和均不超过 1000 。 

输出描述 
对于每一个测试点，在一行上输出一个整数，代表不同的摆放方式数量。如果无法将魔法阅读桌放入阅读室，那么输出 0 。 样例输入 1 3 1 2 2 样例输出 4 提示 对于第一个测试点，已经在题目中加以解释。 对于第二个测试点，无法将魔法桌放入阅读室。

样例输入
2
3 1 2 2
1 2 3 7

样例输出
4
0

提示
对于第一个测试点，已经在题目中加以解释。

对于第二个测试点，无法将魔法桌放入阅读室。


### 第三题
#### 题目描述：
小红有一棵由 n 个节点、 n - 1 条无向边构成的树，每条边的权值为 wi。

定义树上两个点 (u,v) 的权值为，从 u 到 v 的简单路径上，全部边权的异或和，特别的，当 u 和 v 为同一个点时，权值为 0 。

小红会提出 q 次询问，每次询问要求计算有多少个点到节点 u 的权值恰好为 k 。

树是指这样的一张图，其上的任意两个点都连通，且不存在环。

简单路径是指两个节点之间的一条路径，其不包含任何重复的节点。也就是说，在简单路径上，每个节点只能出现一次。



输入描述
第一行输入两个整数 n,q( 1≤n , q≤105)，分别表示节点总数和询问次数。

此后 n-1 行，第 i 行输入三个整数 ui , vi 和 wi（ 1≤ui , vi≤n ; ui≠vi ; 0≤w≤260 ）表示树上第 i 条边连接节点 ui 和 vi 且边权为 wi 。保证树联通，没有重边。

此后 q 行，每行输入两个整数 u,k(1≤u≤n,0≤k≤260)代表被询问的节点和限定。

输出描述
对于每一个询问，在一行上输出一个整数，代表到节点 u 的权值恰好为 k 的节点数量。


样例输入
3 2
1 2 2
1 3 3
1 0
2 2

样例输出
1
1

提示
对于第一个询问，只有 1 号结点到 1 号结点的路径异或和为 0。

对于第二个询问，只有 1 号结点到 2 号结点的路径异或和为 2。

## 中兴
单选题：2+3+2 应该是
多选题：2+3
编程题：2道

### 第一题：选择排序
#### 题目描述
简单选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

现在需要得到序列第 i 趟排序后的结果（本题中采用每轮选取选出最小值的方式）。比如给定趟数 3 和序列 (45 88 48 40 21 73) 。根据选择排序的算法：
第一趟：21 88 48 40 45 73

第二趟：21 40 48 88 45 73

第三趟：21 40 45 88 48 73

由此可以得到第三趟的输出为 (21 40 45 88 48 73)。

#### 输入描述：
输入包含多组，每组由两行组成：

第一行为正整数i，代表需要做的简单排序的趟数；

第二行为正整数序列，包含用空格隔开的多个值（i<=序列长度，序列长度最大为100）。
输出描述：


#### 输出描述：
输出经过第i趟排序后的正整数序列（用空格分隔元素）。


#### 代码实现
```java
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        while (scanner.hasNextLine()) {
            // 读取第一个输入：趟数 i
            String line1 = scanner.nextLine();
            if (line1 == null || line1.trim().isEmpty()) {
                break;
            }
            int passes = Integer.parseInt(line1.trim());
            
            // 读取第二个输入：待排序的序列
            if (!scanner.hasNextLine()) {
                break;
            }
            String line2 = scanner.nextLine();
            if (line2 == null || line2.trim().isEmpty()) {
                break;
            }
            String[] tokens = line2.trim().split("\\s+");
            int[] arr = new int[tokens.length];
            for (int i = 0; i < tokens.length; i++) {
                arr[i] = Integer.parseInt(tokens[i]);
            }
            
            // 对序列进行选择排序的前 passes 趟
            int n = arr.length;
            for (int i = 0; i < passes && i < n - 1; i++) {
                int minIndex = i;
                for (int j = i + 1; j < n; j++) {
                    if (arr[j] < arr[minIndex]) {
                        minIndex = j;
                    }
                }
                // 交换当前元素和最小元素
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
            
            // 输出第 i 趟排序后的序列
            for (int i = 0; i < arr.length; i++) {
                System.out.print(arr[i]);
                if (i != arr.length - 1) {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
        scanner.close();
    }
}
```


### 第二题：二叉树
#### 题目描述
由数字 1~N 顺序构成的完全二叉树中，其中 1 是根结点。

求从根结点到指定数字对应结点的路径上的数字组成的数字字符串。

#### 输入描述：

整数N，1 <= N <= 1000

#### 输出描述：

从根结点到输入数字的路径结点上的数字组成的数字字符串，数字之间由单个空格间隔。

示例：
输入：5
输出：1 2 5


#### 代码
```java
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 读取输入的整数 N
        int N = scanner.nextInt();
        scanner.close();
        
        // 用于存储路径上的节点
        ArrayList<Integer> path = new ArrayList<>();
        int current = N;
        
        // 构建从目标节点到根节点的路径
        while (current >= 1) {
            path.add(current);
            current /= 2;
        }
        
        // 逆序输出路径（从根节点到目标节点）
        Collections.reverse(path);
        for (int i = 0; i < path.size(); i++) {
            System.out.print(path.get(i));
            if (i != path.size() - 1) {
                System.out.print(" ");
            }
        }
    }
}
```

## 帆软

100分钟：单选5道+不定项选择6道+填空2道+编程题2道

### 第一道：回文串
#### 题目描述
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

回文字符定义为：首尾对称的字符，例如"a","baab","aba"。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

示例 1：
输入：s = "bbbab"
输出：4

解释：一个可能的最长回文子序列为 "bbbb" 。

示例 2：
输入：s = "cbacbd"
输出：3

解释：一个可能的最长回文子序列为 "bab" 。

#### 代码实现
```java
import java.util.Scanner;

public class Main {
    public static int longestPalindromeSubseq(String s) {
        int n = s.length();
        // dp[i][j] 表示 s[i..j] 中最长回文子序列的长度
        int[][] dp = new int[n][n];

        // 从字符串的末尾开始遍历
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1; // 单个字符的回文子序列长度为1
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    // 如果字符相等，长度加2
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    // 如果字符不相等，取两种情况的最大值
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        // 返回整个字符串的最长回文子序列长度
        return dp[0][n - 1];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 读取输入字符串
        String s = scanner.nextLine();
        scanner.close();
        // 计算最长回文子序列的长度
        int result = longestPalindromeSubseq(s);
        // 输出结果
        System.out.println(result);
    }
}
```

### 第二题
#### 题目描述
输入一个正整数N (1 ≤ N ≤ 44,777,444)，请你返回 k 个正整数 $a_1, a_2, a_3..., a_k$，满足 ${a_1}^3+a_2^3+a_3^3+...+a_k^3 = N$，同时保证 k 的值最小。

返回长度为k的数组，并降序排序

示例：
输入：42 
输出：2 2 2 2 2 1 1

#### 代码
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 读取输入的正整数 N
        int N = scanner.nextInt();
        scanner.close();

        // 预处理：生成所有不超过 N 的立方数
        List<Integer> cubes = new ArrayList<>();
        int maxCubeRoot = (int) Math.cbrt(N);
        for (int i = 1; i <= maxCubeRoot; i++) {
            cubes.add(i * i * i);
        }

        // 使用 BFS 或 A* 搜索最小的 k
        List<Integer> result = findMinCubes(N, cubes);

        // 将结果降序排序并输出
        Collections.sort(result, Collections.reverseOrder());
        for (int i = 0; i < result.size(); i++) {
            System.out.print(result.get(i));
            if (i != result.size() - 1) {
                System.out.print(" ");
            }
        }
    }

    private static List<Integer> findMinCubes(int N, List<Integer> cubes) {
        // 使用 HashMap 存储每个状态的最小 k 值
        Map<Integer, List<Integer>> memo = new HashMap<>();
        Queue<Node> queue = new LinkedList<>();
        queue.offer(new Node(N, new ArrayList<>()));

        while (!queue.isEmpty()) {
            Node current = queue.poll();
            int remainder = current.remainder;
            List<Integer> path = current.path;

            // 如果已经计算过且当前路径长度不小于已存在的路径长度，跳过
            if (memo.containsKey(remainder) && memo.get(remainder).size() <= path.size()) {
                continue;
            }

            memo.put(remainder, path);

            if (remainder == 0) {
                return path;
            }

            // 尝试所有可能的立方数
            for (int i = cubes.size() - 1; i >= 0; i--) {
                int cube = cubes.get(i);
                if (cube <= remainder) {
                    List<Integer> newPath = new ArrayList<>(path);
                    newPath.add((int) Math.cbrt(cube));
                    queue.offer(new Node(remainder - cube, newPath));
                }
            }
        }

        // 理论上不会到这里，保证一定有解
        return new ArrayList<>();
    }

    static class Node {
        int remainder;
        List<Integer> path;

        Node(int remainder, List<Integer> path) {
            this.remainder = remainder;
            this.path = path;
        }
    }
}
```

## 海康威视

2个小时：25道单选+10道多选+2道编程

### 第一道：字符串去重

编写一个方法，对只有小写字母的字符串进行去重，并保持字母在字符串中首次出现的顺序。
输入描述
输入一串带重复字符的字符串，输出第一次出现的字符的字符串

输出描述
对只有小写字母的字符串进行去重并输出

样例输入
hikvision

样例输出
hikvson

#### 代码
```java
import java.util.LinkedHashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        // 创建一个扫描器对象获取输入
        Scanner scanner = new Scanner(System.in);
        
        // 获取输入的字符串
        String input = scanner.nextLine();
        
        // 调用去重方法并打印输出
        System.out.println(removeDuplicates(input));
        
        // 关闭扫描器
        scanner.close();
    }

    // 去除字符串中的重复字符并保持首次出现顺序
    public static String removeDuplicates(String input) {
        // 创建一个有序的Set来存储字符，LinkedHashSet保持插入顺序
        Set<Character> charSet = new LinkedHashSet<>();
        
        // 遍历输入字符串，将每个字符放入set中
        for (char ch : input.toCharArray()) {
            charSet.add(ch);
        }

        // 将Set中的字符拼接为字符串
        StringBuilder result = new StringBuilder();
        for (char ch : charSet) {
            result.append(ch);
        }

        return result.toString();
    }
}

```

#### 代码说明

1. 使用 `LinkedHashSet` 保证字符按照插入顺序存储，同时自动去重。
2. 遍历输入字符串，将每个字符插入 `LinkedHashSet`，如果字符已经存在，`Set` 会自动处理重复字符。
3. 最后将 `Set` 中的字符拼接成字符串并返回

### 第二题 SQL 查找

#### 题目描述

数据库-每个用户每周的活跃天数

有如下表  user_login 

date           user_id            time

20230101     1           2023-01-01 09:01:00

20230101     1           2023-01-01 11:02:00

20230101     2           2023-01-02 10:08:00

20230102     2           2023-01-02 15:05:00

求每个用户每周的活跃天数

输入描述
建表及插入数据

输出描述
查询结果，userid、第几周、活跃天数

示例：
样例输入
CREATE TABLE user_login(date DATE,user_id int ,time DATETIME);

insert into user_login value('20230101',1,'2023-01-01 09:01:00');

insert into user_login value('20230101',1,'2023-01-01 11:02:00');

insert into user_login value('20230102',2,'2023-01-02 10:08:00');

insert into user_login value('20230102',3,'2023-01-02 15:05:00');

样例输出
||||
|-----|-----|-----|
1 | 202301 | 1
2 | 202301 | 1
3 | 202301 | 1


#### 代码
```sql
SELECT 
    user_id,
    YEAR(date)*100 + FLOOR((DAYOFYEAR(date)-1)/7)+1 AS week_number,
    COUNT(DISTINCT date) AS active_days
FROM 
    user_login
GROUP BY 
    user_id, week_number;
```


#### 代码解释

1. **计算周编号：**
    
    - `YEAR(date)*100`：获取日期的年份并乘以 100，以便为周编号预留两位数的位置。
    - `FLOOR((DAYOFYEAR(date)-1)/7)+1`：计算日期在一年中的第几周。`DAYOFYEAR(date)` 获取日期在一年中的第几天，减 1 后除以 7，取整，再加 1 得到周编号。
    - **组合起来**，`YEAR(date)*100 + FLOOR((DAYOFYEAR(date)-1)/7)+1` 得到类似 `202301` 的周编号。
2. **计算活跃天数：**
    
    - `COUNT(DISTINCT date)`：统计每个用户在该周内登录的不同日期数量。
3. **分组：**
    
    - `GROUP BY user_id, week_number`：按照用户和周编号分组，计算每个用户每周的活跃天数。


## TCL

人才测评（自有系统）

英文笔试：一个阅读理解题（一篇文章，7个问题）；一道写作题



## 深信服
> 投递三天后发了笔试邮件

<<<<<<< HEAD
选择题+编程题

4道编程题

第一题：输入一个指纹字符串，判有多少个有效设备
定义指纹规则：间隔出现三次的指纹算是一个有效设备
- 只有一个指纹，比如 `AAAA` , 一个
- 所有指纹都不满足规则，一个

第二题：输入一个字符串，判断是否是有效的域名
给出了域名规则：
- 点分隔
- 中间可以有连字符，但是开头和结尾不能有连字符
- 可以是数字和字母



=======
20/30道选择
4道编程
>>>>>>> 94057db26b2418f208958e92c5345f50b75adf27


## 中国网安

### 人才测评
投递第二天发了人才测评邮件

> 和大部分的人才测评类似

第一部分：言语理解
第二部分：数量计算
第三部分：图形推理

第四和第五部分为性格测试

没有消息了......


## 海信

### 人才测评

投递第二天发了人才测评邮件

和大部分的人才测评类似:

第一部分：言语理解
第二部分：数量计算
第三部分：图形推理

第四和第五部分为性格测试

### 在线笔试
>做完人才测评第二天发了笔试邮件，要求72小时内完成

错过了时间，悲伤......

## 海光信息

### 在线笔试

>投递第二天，无人才测评，直接笔试

时间：60分钟
题型：20单选 + 15多选 + 19道填空题

考察操作系统、Linux相关知识偏多


## 招商银行

> 投递第三天，一块发了人才测评和在线笔试

### 人才测评

和大部分的人才测评类似:

第一部分：言语理解
第二部分：数量计算
第三部分：图形推理

第四和第五部分为性格测试

### 在线笔试

第一部分：30分钟，单选题（涉及Java、面向对象、数据库、编程题）
第二部分：60分钟，三道编程题
- 第一道：签到题（补充代码）
- 第二道：判断输入字符串是否为有效的 IPV4 或 IPV6 地址（补充代码）
- 第三道：将输入的字符串进行逆序输出（自己写代码，并要求使用动态规划）
	比如输入： `Apple banana#`  , 输出：`banana Apple`


## 小红书




## 联想

投递第二天，一块发了人才测评和在线笔试

### 人才测评

联想自有题库，也是 言语理解、数量计算、图形推理、逻辑判断 这几个部分。

### 在线笔试

2个小时，一共两部分

第一部分：单选+多选+填空（一定不要花太多时间）

第二部分：两道编程题

**第一题：**

$N*N$ 的网格，给定 每一个小方格中的矿物数量，求最合适的 位置 $[i, j]$ , 使得 $[i, j],\ \ [i-1,j],\ [i+1, j],\ [i, j-1],\ [i,j+1]$ 的矿物数量最多。

**第二题：**

一台机器的初始热量为 $0$，请规划未来 $N$ 天的生产方式，使得在这 $N$ 天内的收益最大。已知第 $i$ 天进行生产增加的热量为 $a_i$ , 得到的收益为 $b_i$,  如果不进行生产，减少的热量为 $c_i$ .

